CCS PCH C Compiler, Version 4.104, 5967               18-Nov-14 13:07

               Filename: D:\DNPR_DATA_LOGGER\131114\PIC_Logger_R1000\logger.lst

               ROM used: 14924 bytes (46%)
                         Largest free fragment is 17840
               RAM used: 112 (7%) at main() level
                         431 (28%) worst case
               Stack:    6 worst case (4 in main + 2 for interrupts)

*
0000:  GOTO   2430
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   0642
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   0692
0060:  BTFSS  FF2.4
0062:  GOTO   006C
0066:  BTFSC  FF2.1
0068:  GOTO   06AC
006C:  BTFSS  FF0.3
006E:  GOTO   0078
0072:  BTFSC  FF0.0
0074:  GOTO   06B8
0078:  BTFSS  FF0.4
007A:  GOTO   0084
007E:  BTFSC  FF0.1
0080:  GOTO   06B2
0084:  BTFSS  F9D.6
0086:  GOTO   0090
008A:  BTFSC  F9E.6
008C:  GOTO   063C
0090:  BTFSS  F9D.5
0092:  GOTO   009C
0096:  BTFSC  F9E.5
0098:  GOTO   06BE
009C:  MOVFF  0E,00
00A0:  MOVFF  0F,01
00A4:  MOVFF  10,02
00A8:  MOVFF  11,03
00AC:  MOVFF  0C,FE9
00B0:  MOVFF  07,FEA
00B4:  BSF    07.7
00B6:  MOVFF  08,FE1
00BA:  MOVFF  09,FE2
00BE:  MOVFF  0A,FD9
00C2:  MOVFF  0B,FDA
00C6:  MOVFF  12,FF3
00CA:  MOVFF  13,FF4
00CE:  MOVFF  14,FFA
00D2:  MOVF   04,W
00D4:  MOVFF  06,FE0
00D8:  MOVFF  05,FD8
00DC:  RETFIE 0
.................... //       SAJJAD HUSSAIN, S.E. 
.................... //       SEP. 2014 
.................... //       DATA LOGGER 
....................  
.................... #include "logger.h" 
.................... //       SAJJAD HUSSAIN, S.E. 
.................... //       SEP. 2014 
.................... //       DATA LOGGER 
....................  
....................  
.................... //#include <18F4520.h> 
.................... #include <18F458.h> 
.................... //////// Standard Header file for the PIC18F458 device //////////////// 
.................... #device PIC18F458 
.................... #list 
....................  
....................  
.................... #device adc=8 
.................... #DEVICE WRITE_EEPROM = NOINT 
.................... //right near the top of your source 
.................... #device PASS_STRINGS=IN_RAM  
....................  
.................... //#fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #fuses EC,NOWDT,NOPROTECT,NOLVP 
.................... //#fuses EC, NOOSCSEN,NOPUT,NOBROWNOUT,NOWDT,NOSTVREN,NOLVP,NODEBUG,NOPROTECT,NOCPD,NOWRT,NOWRTC 
.................... /* 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES XT 
.................... //#FUSES EC                    //External clock 
.................... //#FUSES EC_IO                    //External clock 
.................... //#FUSES HS 
.................... //#FUSES INTRC_IO                 //Internal RC Osc, no CLKOUT 
.................... //#FUSES INTRC 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... //#FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... //#FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... //#FUSES NOWRTD                   //Data EEPROM not write protected 
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled 
.................... //#FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... //#FUSES NOPBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... //#FUSES NOWRTC                   //configuration not registers write protected 
.................... //#FUSES NOWRTB                   //Boot block not write protected 
.................... //#FUSES NOEBTR                   //Memory not protected from table reads 
.................... //#FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... //#FUSES NOCPB                    //No Boot Block code protection 
.................... //#FUSES NOLPT1OSC                  //Timer1 configured for low-power operation 
.................... //#FUSES MCLR                     //Master Clear pin enabled 
.................... //#FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... */ 
.................... //#use delay(clock=11059200) 
.................... //#use delay(clock=4090000) 
.................... #use delay(clock=8192000) 
*
06E4:  MOVLW  01
06E6:  MOVWF  FEA
06E8:  MOVLW  AA
06EA:  MOVWF  FE9
06EC:  MOVF   FEF,W
06EE:  BZ    070A
06F0:  MOVLW  02
06F2:  MOVWF  01
06F4:  CLRF   00
06F6:  DECFSZ 00,F
06F8:  BRA    06F6
06FA:  DECFSZ 01,F
06FC:  BRA    06F4
06FE:  MOVLW  A7
0700:  MOVWF  00
0702:  DECFSZ 00,F
0704:  BRA    0702
0706:  DECFSZ FEF,F
0708:  BRA    06F0
070A:  RETLW  00
.................... #use rs232(baud=57600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,STOP=2) 
070C:  BTFSS  F9E.4
070E:  BRA    070C
0710:  MOVLB  1
0712:  MOVF   xAA,W
0714:  MOVWF  FAD
0716:  BTFSS  FAC.1
0718:  BRA    0716
071A:  MOVLW  16
071C:  MOVWF  00
071E:  DECFSZ 00,F
0720:  BRA    071E
0722:  BRA    0724
0724:  MOVLB  0
0726:  RETLW  00
.................... #ROM int8 0xf00000 = {7, 8, 0, 0, 0, 0,1,0,1}// byte wise 
.................... //default memory values 
.................... //location 0: status byte 0 (lsb)  includes rate, filter clock, impedance 
.................... //location 1: status byte 1 include system id 
.................... //location 2: status byte 2 (msb)  includes  Tid  
.................... //location 3: Start Addr Running byte 0 (lsb) 
.................... //location 4: Start Addr Running byte 1  
.................... //location 5: Start Addr Running byte 2 (msb)  
.................... //location 6: Acquiring Time (lsb) T = 1s to 999s 
.................... //location 7: Acquiring Time (msb) 
.................... //location 8: System ID 
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // PIN DECLARATIONS 
.................... #byte PORTA     = 0x0F80 
.................... #byte PORTB     = 0x0F81 
.................... #byte PORTC     = 0x0F82 
.................... #byte PORTD     = 0x0F83 
.................... #byte PORTE     = 0x0F84 
.................... #byte ADCON1    = 0x0FC1 
....................  
.................... #define START    PIN_B1 
.................... #define RESET    PIN_B0 
.................... #define CSu    PIN_C1 
.................... #define DONE    PIN_B2 
.................... #define UART    PIN_C0 
.................... #define eSDO   PIN_C5 
.................... #define eSCLK  PIN_C3 
....................  
.................... #bit LCD_BL = PORTA.1 
.................... #bit LCD_E2 = PORTA.2 
.................... #bit LCD_RS = PORTA.3 
.................... //#bit LCD_E1 = PORTA.4 
.................... #bit LCD_E1 = PORTD.0 
.................... #bit LCD_D4  = PORTE.0 
.................... #bit LCD_D5  = PORTA.5 
.................... #bit LCD_D6  = PORTE.2 
.................... #bit LCD_D7 =  PORTE.1 
.................... //       CONSTANTS FOR UNDERSTANDING 
.................... #define PC  1 
.................... #define FPGA 0 
.................... #define SPI_PIC      0x00000100 
.................... #define SPI_FPGA     0x00000000 
.................... #define EEP0         0x00000000 
.................... #define EEP1         0x00000200 
.................... #define EEP2         0x00000400 
.................... #define EEP3         0x00000600 
.................... #define CMD_START    0x08000000 
.................... #define CMD_STOP     0x0a000000 
.................... #define CMD_STATUS   0x0c000000 
.................... #define CMD_CONECT   0x0b000000 
.................... #define CMD_EOF   0x0e000000 
.................... #define CMD_EOF2   0x0f000000 
....................  
.................... //Screen Modes 
.................... #define REDY  0 
.................... #define ACQR   1 
.................... #define SEND   2 
.................... #define ERAS  3 
.................... #define CNCT  4 
....................  
.................... //Receive Letters 
.................... #define lKey   0x100// Left Key 
.................... #define dKey   0x200//Down 
.................... #define oKey   0x300//Ok 
.................... #define uKey   0x400//Up 
.................... #define rKey   0x500//Right 
.................... #define sAck 0xc00// Acknowledge Start Receieved 
.................... #define eAck   0xe00// End of Record Receieved 
.................... #define eAck2   0xf00// End of All Records Receieved 
.................... #define pAck  0xd00// Page Receieved 
.................... #define cAck  0xb00// Connection Receieved 
....................  
....................  
.................... #define ready     1 
.................... #define mn_conn   2 
.................... #define mn_send  3 
.................... #define mn_erase 4 
.................... #define mn_main       5 
.................... #define mn_acquire   6 
.................... #define unitary       8 
.................... #define sampling       9 
.................... #define impedance        10 
.................... #define frequency        11 
.................... #define mem_erase     12 
.................... #define mn_yes    13 
.................... #define tenth       14 
.................... #define hunderth       15 
.................... #define wait_cAck    16 
.................... #define wait_sAck        17 
.................... #define wait_pAck1      18 
.................... #define wait_eAck    19 
.................... #define wait_pAck2    20 
.................... #define wait_eAck2    21 
....................  
.................... //             VARIABLES 
.................... unsigned char cntms,cnt40ms;//Count timer 
.................... unsigned int16 rxChr;// serial char 
.................... unsigned int32 status;// status register 
.................... unsigned char Module;// LCD enable 1/2 
.................... unsigned char state;//state variable 
.................... unsigned int32 Tid;//Test ID 
.................... unsigned int32 Sid;//System ID 
.................... unsigned int16 T;        // Experiment Time (sec) 3 digits 
.................... char T0=0,T1=0,T2=0; 
.................... unsigned char Tm;       // Maximum Time (sec) w.r.t Memory M and Rate R 
.................... unsigned char M=0;      // Available Memory (MB) 
.................... unsigned int8 B=100;    // Battery Percentage 
.................... unsigned char R;        // Rate (K-samp/sec) 
.................... unsigned int32 Z;     // Impedance 
.................... unsigned int32 F;     // Cutoff Frequency 
.................... unsigned int32 N;       //Total samples in time T at Rate R (kilo) 
.................... char s[10]; 
.................... boolean kflag=0; 
.................... boolean online=0; 
.................... boolean expired=0; 
.................... //unsigned char AA[256]; 
.................... //unsigned int32 k; 
.................... unsigned int32 StopAddr,StartAddr; 
.................... unsigned int32 RecStartAddr,RecStopAddr; 
.................... unsigned int32 TOT = 16368;//32752 
.................... unsigned int32 page; 
.................... unsigned int32 record; 
....................  
.................... //                   Function Prototypes 
.................... void LcdInit(); 
.................... void LcdWriteCmd(unsigned char c); 
.................... void LcdWriteChar(unsigned char var); 
.................... void LcdWriteStr(unsigned char *var); 
.................... void LcdGotoXY(unsigned char r,unsigned char c); 
.................... void EraseEE(void); 
.................... void WriteEE(void); 
.................... void ReadEE(void); 
.................... void SendCmd(unsigned int32 cmd); 
.................... void GenStatus(void); 
.................... void SendPage(unsigned int32 G, unsigned int32 EEPROM); 
.................... void SaveRec(unsigned int32 Test); 
.................... void Sel_UART(boolean dev); 
....................  
.................... ///////////////  Make Status bytes from individual bits  //////////////////// 
.................... void GenStatus (void) 
.................... { 
....................    //reset status variable 
....................    status = 0; 
*
0C8E:  CLRF   23
0C90:  CLRF   22
0C92:  CLRF   21
0C94:  CLRF   20
....................     
....................    // update rate 3 bits 
....................    //set control signals 
....................    if(R==1) 
0C96:  DECFSZ 36,W
0C98:  BRA    0CA0
....................       status |= 0b111; 
0C9A:  MOVLW  07
0C9C:  IORWF  20,F
....................    else if (R == 8) 
0C9E:  BRA    0CB4
0CA0:  MOVF   36,W
0CA2:  SUBLW  08
0CA4:  BNZ   0CAC
....................       status |= 0b011; 
0CA6:  MOVLW  03
0CA8:  IORWF  20,F
....................    else if (R == 16) 
0CAA:  BRA    0CB4
0CAC:  MOVF   36,W
0CAE:  SUBLW  10
0CB0:  BNZ   0CB4
....................       status |= 0b001; 
0CB2:  BSF    20.0
....................    // update filter clock 2 bits 
....................    if (F==4000) 
0CB4:  MOVF   3B,W
0CB6:  SUBLW  A0
0CB8:  BNZ   0CCA
0CBA:  MOVF   3C,W
0CBC:  SUBLW  0F
0CBE:  BNZ   0CCA
0CC0:  MOVF   3D,F
0CC2:  BNZ   0CCA
0CC4:  MOVF   3E,F
0CC6:  BNZ   0CCA
....................       status |= 0b01000; 
0CC8:  BSF    20.3
....................    // update Impedance bit 
....................    if (Z==50) 
0CCA:  MOVF   37,W
0CCC:  SUBLW  32
0CCE:  BNZ   0CDE
0CD0:  MOVF   38,F
0CD2:  BNZ   0CDE
0CD4:  MOVF   39,F
0CD6:  BNZ   0CDE
0CD8:  MOVF   3A,F
0CDA:  BNZ   0CDE
....................       status |= 0b100000; 
0CDC:  BSF    20.5
....................  
....................    status = status|(Tid<<16);//shift Tid to 3rd byte 
0CDE:  CLRF   00
0CE0:  CLRF   01
0CE2:  MOVF   00,W
0CE4:  IORWF  20,F
0CE6:  MOVF   01,W
0CE8:  IORWF  21,F
0CEA:  MOVF   26,W
0CEC:  IORWF  22,F
0CEE:  MOVF   27,W
0CF0:  IORWF  23,F
....................    status = status|(Sid<<11); 
0CF2:  CLRF   00
0CF4:  RLCF   2A,W
0CF6:  MOVWF  01
0CF8:  RLCF   2B,W
0CFA:  MOVWF  02
0CFC:  RLCF   2C,W
0CFE:  MOVWF  03
0D00:  RLCF   01,F
0D02:  RLCF   02,F
0D04:  RLCF   03,F
0D06:  RLCF   01,F
0D08:  RLCF   02,F
0D0A:  RLCF   03,F
0D0C:  MOVLW  F8
0D0E:  ANDWF  01,F
0D10:  MOVF   00,W
0D12:  IORWF  20,F
0D14:  MOVF   01,W
0D16:  IORWF  21,F
0D18:  MOVF   02,W
0D1A:  IORWF  22,F
0D1C:  MOVF   03,W
0D1E:  IORWF  23,F
....................     
....................    //status sel spi uc 
....................    SendCmd(CMD_STATUS | EEP0 | SPI_FPGA | status); 
0D20:  MOVFF  20,95
0D24:  MOVFF  21,96
0D28:  MOVFF  22,97
0D2C:  MOVF   23,W
0D2E:  IORLW  0C
0D30:  MOVWF  x98
0D32:  MOVFF  FE8,1A8
0D36:  MOVFF  22,1A7
0D3A:  MOVFF  21,1A6
0D3E:  MOVFF  20,1A5
0D42:  RCALL  0B4E
....................  
....................    write_eeprom(0,status&0xff); 
0D44:  MOVF   20,W
0D46:  MOVWF  x95
0D48:  CLRF   x96
0D4A:  CLRF   x97
0D4C:  CLRF   x98
0D4E:  CLRF   FA9
0D50:  MOVFF  95,FA8
0D54:  BCF    FA6.6
0D56:  BCF    FA6.7
0D58:  BSF    FA6.2
0D5A:  MOVF   FF2,W
0D5C:  MOVWF  00
0D5E:  BCF    FF2.7
0D60:  MOVLB  F
0D62:  MOVLW  55
0D64:  MOVWF  FA7
0D66:  MOVLW  AA
0D68:  MOVWF  FA7
0D6A:  BSF    FA6.1
0D6C:  MOVF   00,W
0D6E:  IORWF  FF2,F
0D70:  BTFSC  FA6.1
0D72:  BRA    0D70
0D74:  BCF    FA6.2
....................    write_eeprom(1,(status>>8)&0xff); 
0D76:  MOVFF  21,96
0D7A:  MOVFF  22,97
0D7E:  MOVFF  23,98
0D82:  MOVLB  0
0D84:  CLRF   x99
0D86:  CLRF   x97
0D88:  CLRF   x98
0D8A:  CLRF   x99
0D8C:  MOVLW  01
0D8E:  MOVWF  FA9
0D90:  MOVFF  96,FA8
0D94:  BCF    FA6.6
0D96:  BCF    FA6.7
0D98:  BSF    FA6.2
0D9A:  MOVF   FF2,W
0D9C:  MOVWF  00
0D9E:  BCF    FF2.7
0DA0:  MOVLB  F
0DA2:  MOVLW  55
0DA4:  MOVWF  FA7
0DA6:  MOVLW  AA
0DA8:  MOVWF  FA7
0DAA:  BSF    FA6.1
0DAC:  MOVF   00,W
0DAE:  IORWF  FF2,F
0DB0:  BTFSC  FA6.1
0DB2:  BRA    0DB0
0DB4:  BCF    FA6.2
....................    write_eeprom(2,(status>>16)&0xff); 
0DB6:  MOVFF  22,96
0DBA:  MOVFF  23,97
0DBE:  MOVLB  0
0DC0:  CLRF   x98
0DC2:  CLRF   x99
0DC4:  CLRF   x97
0DC6:  CLRF   x98
0DC8:  CLRF   x99
0DCA:  MOVLW  02
0DCC:  MOVWF  FA9
0DCE:  MOVFF  96,FA8
0DD2:  BCF    FA6.6
0DD4:  BCF    FA6.7
0DD6:  BSF    FA6.2
0DD8:  MOVF   FF2,W
0DDA:  MOVWF  00
0DDC:  BCF    FF2.7
0DDE:  MOVLB  F
0DE0:  MOVLW  55
0DE2:  MOVWF  FA7
0DE4:  MOVLW  AA
0DE6:  MOVWF  FA7
0DE8:  BSF    FA6.1
0DEA:  MOVF   00,W
0DEC:  IORWF  FF2,F
0DEE:  BTFSC  FA6.1
0DF0:  BRA    0DEE
0DF2:  BCF    FA6.2
....................    delay_ms(1); 
0DF4:  MOVLW  01
0DF6:  MOVLB  1
0DF8:  MOVWF  xAA
0DFA:  MOVLB  0
0DFC:  RCALL  06E4
....................     
....................    //Calculate Tm 
....................    Tm = TOT/(R*4);//Seconds 
0DFE:  MOVF   36,W
0E00:  MULLW  04
0E02:  MOVFF  FF3,95
0E06:  MOVFF  61,CE
0E0A:  MOVFF  60,CD
0E0E:  MOVFF  5F,CC
0E12:  MOVFF  5E,CB
0E16:  CLRF   xD2
0E18:  CLRF   xD1
0E1A:  CLRF   xD0
0E1C:  MOVFF  95,CF
0E20:  RCALL  079E
0E22:  MOVFF  00,33
....................    //if(T>Tm) T = Tm; //incase R is increased 
....................    N = T; N = N *R;//in Kilo 
0E26:  CLRF   42
0E28:  CLRF   41
0E2A:  MOVFF  2F,40
0E2E:  MOVFF  2E,3F
0E32:  MOVFF  42,A0
0E36:  MOVFF  41,9F
0E3A:  MOVFF  40,9E
0E3E:  MOVFF  3F,9D
0E42:  CLRF   xA4
0E44:  CLRF   xA3
0E46:  CLRF   xA2
0E48:  MOVFF  36,A1
0E4C:  RCALL  074A
0E4E:  MOVFF  03,42
0E52:  MOVFF  02,41
0E56:  MOVFF  01,40
0E5A:  MOVFF  00,3F
.................... } 
0E5E:  RETLW  00
....................  
.................... //////////////// Generate individual bits from status bytes //////////////// 
.................... void ReloadStatus(void) 
.................... { 
....................    status = read_eeprom(2); 
*
0818:  MOVFF  FF2,95
081C:  BCF    FF2.7
081E:  MOVLW  02
0820:  MOVWF  FA9
0822:  BCF    FA6.6
0824:  BCF    FA6.7
0826:  BSF    FA6.0
0828:  MOVF   FA8,W
082A:  BTFSC  x95.7
082C:  BSF    FF2.7
082E:  CLRF   23
0830:  CLRF   22
0832:  CLRF   21
0834:  MOVWF  20
....................    status = (status<<8) + read_eeprom(1); 
0836:  MOVFF  22,99
083A:  MOVFF  21,98
083E:  MOVFF  20,97
0842:  CLRF   x96
0844:  MOVFF  FF2,9A
0848:  BCF    FF2.7
084A:  MOVLW  01
084C:  MOVWF  FA9
084E:  BCF    FA6.6
0850:  BCF    FA6.7
0852:  BSF    FA6.0
0854:  MOVF   FA8,W
0856:  BTFSC  x9A.7
0858:  BSF    FF2.7
085A:  ADDWF  x96,W
085C:  MOVWF  20
085E:  MOVLW  00
0860:  ADDWFC x97,W
0862:  MOVWF  21
0864:  MOVLW  00
0866:  ADDWFC x98,W
0868:  MOVWF  22
086A:  MOVLW  00
086C:  ADDWFC x99,W
086E:  MOVWF  23
....................    status = (status<<8) + read_eeprom(0); 
0870:  MOVFF  22,99
0874:  MOVFF  21,98
0878:  MOVFF  20,97
087C:  CLRF   x96
087E:  MOVFF  FF2,9A
0882:  BCF    FF2.7
0884:  CLRF   FA9
0886:  BCF    FA6.6
0888:  BCF    FA6.7
088A:  BSF    FA6.0
088C:  MOVF   FA8,W
088E:  BTFSC  x9A.7
0890:  BSF    FF2.7
0892:  ADDWF  x96,W
0894:  MOVWF  20
0896:  MOVLW  00
0898:  ADDWFC x97,W
089A:  MOVWF  21
089C:  MOVLW  00
089E:  ADDWFC x98,W
08A0:  MOVWF  22
08A2:  MOVLW  00
08A4:  ADDWFC x99,W
08A6:  MOVWF  23
....................    StartAddr = read_eeprom(5); 
08A8:  MOVFF  FF2,95
08AC:  BCF    FF2.7
08AE:  MOVLW  05
08B0:  MOVWF  FA9
08B2:  BCF    FA6.6
08B4:  BCF    FA6.7
08B6:  BSF    FA6.0
08B8:  MOVF   FA8,W
08BA:  BTFSC  x95.7
08BC:  BSF    FF2.7
08BE:  CLRF   55
08C0:  CLRF   54
08C2:  CLRF   53
08C4:  MOVWF  52
....................    StartAddr = (StartAddr<<8) + read_eeprom(4); 
08C6:  MOVFF  54,99
08CA:  MOVFF  53,98
08CE:  MOVFF  52,97
08D2:  CLRF   x96
08D4:  MOVFF  FF2,9A
08D8:  BCF    FF2.7
08DA:  MOVLW  04
08DC:  MOVWF  FA9
08DE:  BCF    FA6.6
08E0:  BCF    FA6.7
08E2:  BSF    FA6.0
08E4:  MOVF   FA8,W
08E6:  BTFSC  x9A.7
08E8:  BSF    FF2.7
08EA:  ADDWF  x96,W
08EC:  MOVWF  52
08EE:  MOVLW  00
08F0:  ADDWFC x97,W
08F2:  MOVWF  53
08F4:  MOVLW  00
08F6:  ADDWFC x98,W
08F8:  MOVWF  54
08FA:  MOVLW  00
08FC:  ADDWFC x99,W
08FE:  MOVWF  55
....................    StartAddr = (StartAddr<<8) + read_eeprom(3); 
0900:  MOVFF  54,99
0904:  MOVFF  53,98
0908:  MOVFF  52,97
090C:  CLRF   x96
090E:  MOVFF  FF2,9A
0912:  BCF    FF2.7
0914:  MOVLW  03
0916:  MOVWF  FA9
0918:  BCF    FA6.6
091A:  BCF    FA6.7
091C:  BSF    FA6.0
091E:  MOVF   FA8,W
0920:  BTFSC  x9A.7
0922:  BSF    FF2.7
0924:  ADDWF  x96,W
0926:  MOVWF  52
0928:  MOVLW  00
092A:  ADDWFC x97,W
092C:  MOVWF  53
092E:  MOVLW  00
0930:  ADDWFC x98,W
0932:  MOVWF  54
0934:  MOVLW  00
0936:  ADDWFC x99,W
0938:  MOVWF  55
....................    T = read_eeprom(7); 
093A:  MOVFF  FF2,95
093E:  BCF    FF2.7
0940:  MOVLW  07
0942:  MOVWF  FA9
0944:  BCF    FA6.6
0946:  BCF    FA6.7
0948:  BSF    FA6.0
094A:  MOVF   FA8,W
094C:  BTFSC  x95.7
094E:  BSF    FF2.7
0950:  CLRF   2F
0952:  MOVWF  2E
....................    T = (T<<8) + read_eeprom(6); 
0954:  MOVFF  2E,96
0958:  CLRF   x95
095A:  MOVFF  FF2,97
095E:  BCF    FF2.7
0960:  MOVLW  06
0962:  MOVWF  FA9
0964:  BCF    FA6.6
0966:  BCF    FA6.7
0968:  BSF    FA6.0
096A:  MOVF   FA8,W
096C:  BTFSC  x97.7
096E:  BSF    FF2.7
0970:  ADDWF  x95,W
0972:  MOVWF  2E
0974:  MOVLW  00
0976:  ADDWFC x96,W
0978:  MOVWF  2F
....................     
....................    Sid = read_eeprom(1) & 0xf8; 
097A:  MOVFF  FF2,95
097E:  BCF    FF2.7
0980:  MOVLW  01
0982:  MOVWF  FA9
0984:  BCF    FA6.6
0986:  BCF    FA6.7
0988:  BSF    FA6.0
098A:  MOVF   FA8,W
098C:  BTFSC  x95.7
098E:  BSF    FF2.7
0990:  ANDLW  F8
0992:  MOVWF  2A
0994:  CLRF   2B
0996:  CLRF   2C
0998:  CLRF   2D
....................    Sid = Sid>>3; 
099A:  RRCF   2D,F
099C:  RRCF   2C,F
099E:  RRCF   2B,F
09A0:  RRCF   2A,F
09A2:  RRCF   2D,F
09A4:  RRCF   2C,F
09A6:  RRCF   2B,F
09A8:  RRCF   2A,F
09AA:  RRCF   2D,F
09AC:  RRCF   2C,F
09AE:  RRCF   2B,F
09B0:  RRCF   2A,F
09B2:  MOVLW  1F
09B4:  ANDWF  2D,F
....................    Tid = read_eeprom(2); 
09B6:  MOVFF  FF2,95
09BA:  BCF    FF2.7
09BC:  MOVLW  02
09BE:  MOVWF  FA9
09C0:  BCF    FA6.6
09C2:  BCF    FA6.7
09C4:  BSF    FA6.0
09C6:  MOVF   FA8,W
09C8:  BTFSC  x95.7
09CA:  BSF    FF2.7
09CC:  CLRF   29
09CE:  CLRF   28
09D0:  CLRF   27
09D2:  MOVWF  26
....................     
....................    // Differentiate 
....................    if ((status&0x07) == 0b001) 
09D4:  MOVF   20,W
09D6:  ANDLW  07
09D8:  MOVWF  x95
09DA:  CLRF   x96
09DC:  CLRF   x97
09DE:  CLRF   x98
09E0:  DECFSZ x95,W
09E2:  BRA    09F6
09E4:  MOVF   x96,F
09E6:  BNZ   09F6
09E8:  MOVF   x97,F
09EA:  BNZ   09F6
09EC:  MOVF   x98,F
09EE:  BNZ   09F6
....................       R = 16; 
09F0:  MOVLW  10
09F2:  MOVWF  36
....................    else if ((status&0x07) == 0b011) 
09F4:  BRA    0A3C
09F6:  MOVF   20,W
09F8:  ANDLW  07
09FA:  MOVWF  x95
09FC:  CLRF   x96
09FE:  CLRF   x97
0A00:  CLRF   x98
0A02:  MOVF   x95,W
0A04:  SUBLW  03
0A06:  BNZ   0A1A
0A08:  MOVF   x96,F
0A0A:  BNZ   0A1A
0A0C:  MOVF   x97,F
0A0E:  BNZ   0A1A
0A10:  MOVF   x98,F
0A12:  BNZ   0A1A
....................       R = 8; 
0A14:  MOVLW  08
0A16:  MOVWF  36
....................    else if ((status&0x07) == 0b111) 
0A18:  BRA    0A3C
0A1A:  MOVF   20,W
0A1C:  ANDLW  07
0A1E:  MOVWF  x95
0A20:  CLRF   x96
0A22:  CLRF   x97
0A24:  CLRF   x98
0A26:  MOVF   x95,W
0A28:  SUBLW  07
0A2A:  BNZ   0A3C
0A2C:  MOVF   x96,F
0A2E:  BNZ   0A3C
0A30:  MOVF   x97,F
0A32:  BNZ   0A3C
0A34:  MOVF   x98,F
0A36:  BNZ   0A3C
....................       R = 1; 
0A38:  MOVLW  01
0A3A:  MOVWF  36
....................        
....................    if ((status&0x18) == 0) 
0A3C:  MOVF   20,W
0A3E:  ANDLW  18
0A40:  MOVWF  x95
0A42:  CLRF   x96
0A44:  CLRF   x97
0A46:  CLRF   x98
0A48:  MOVF   x95,F
0A4A:  BNZ   0A66
0A4C:  MOVF   x96,F
0A4E:  BNZ   0A66
0A50:  MOVF   x97,F
0A52:  BNZ   0A66
0A54:  MOVF   x98,F
0A56:  BNZ   0A66
....................       F = 400; 
0A58:  CLRF   3E
0A5A:  CLRF   3D
0A5C:  MOVLW  01
0A5E:  MOVWF  3C
0A60:  MOVLW  90
0A62:  MOVWF  3B
....................    else if ((status&0x18) == 0x08) 
0A64:  BRA    0A90
0A66:  MOVF   20,W
0A68:  ANDLW  18
0A6A:  MOVWF  x95
0A6C:  CLRF   x96
0A6E:  CLRF   x97
0A70:  CLRF   x98
0A72:  MOVF   x95,W
0A74:  SUBLW  08
0A76:  BNZ   0A90
0A78:  MOVF   x96,F
0A7A:  BNZ   0A90
0A7C:  MOVF   x97,F
0A7E:  BNZ   0A90
0A80:  MOVF   x98,F
0A82:  BNZ   0A90
....................       F = 4000; 
0A84:  CLRF   3E
0A86:  CLRF   3D
0A88:  MOVLW  0F
0A8A:  MOVWF  3C
0A8C:  MOVLW  A0
0A8E:  MOVWF  3B
....................        
....................    if ((status&0x20) == 0) 
0A90:  MOVF   20,W
0A92:  ANDLW  20
0A94:  MOVWF  x95
0A96:  CLRF   x96
0A98:  CLRF   x97
0A9A:  CLRF   x98
0A9C:  MOVF   x95,F
0A9E:  BNZ   0ABA
0AA0:  MOVF   x96,F
0AA2:  BNZ   0ABA
0AA4:  MOVF   x97,F
0AA6:  BNZ   0ABA
0AA8:  MOVF   x98,F
0AAA:  BNZ   0ABA
....................       Z = 324; 
0AAC:  CLRF   3A
0AAE:  CLRF   39
0AB0:  MOVLW  01
0AB2:  MOVWF  38
0AB4:  MOVLW  44
0AB6:  MOVWF  37
....................    else if ((status&0x20) == 0x20) 
0AB8:  BRA    0AE2
0ABA:  MOVF   20,W
0ABC:  ANDLW  20
0ABE:  MOVWF  x95
0AC0:  CLRF   x96
0AC2:  CLRF   x97
0AC4:  CLRF   x98
0AC6:  MOVF   x95,W
0AC8:  SUBLW  20
0ACA:  BNZ   0AE2
0ACC:  MOVF   x96,F
0ACE:  BNZ   0AE2
0AD0:  MOVF   x97,F
0AD2:  BNZ   0AE2
0AD4:  MOVF   x98,F
0AD6:  BNZ   0AE2
....................       Z = 50; 
0AD8:  CLRF   3A
0ADA:  CLRF   39
0ADC:  CLRF   38
0ADE:  MOVLW  32
0AE0:  MOVWF  37
....................        
....................   //M = ((TOT-(StartAddr*2))*100)/TOT; 
....................   M = ((TOT-(StartAddr))*100)/TOT; 
0AE2:  MOVF   52,W
0AE4:  SUBWF  5E,W
0AE6:  MOVWF  x95
0AE8:  MOVF   53,W
0AEA:  SUBWFB 5F,W
0AEC:  MOVWF  x96
0AEE:  MOVF   54,W
0AF0:  SUBWFB x60,W
0AF2:  MOVWF  x97
0AF4:  MOVF   55,W
0AF6:  SUBWFB x61,W
0AF8:  MOVWF  x98
0AFA:  MOVWF  xA0
0AFC:  MOVFF  97,9F
0B00:  MOVFF  96,9E
0B04:  MOVFF  95,9D
0B08:  CLRF   xA4
0B0A:  CLRF   xA3
0B0C:  CLRF   xA2
0B0E:  MOVLW  64
0B10:  MOVWF  xA1
0B12:  RCALL  074A
0B14:  MOVFF  03,98
0B18:  MOVFF  02,97
0B1C:  MOVFF  01,96
0B20:  MOVFF  00,95
0B24:  MOVFF  03,CE
0B28:  MOVFF  02,CD
0B2C:  MOVFF  01,CC
0B30:  MOVFF  00,CB
0B34:  MOVFF  61,D2
0B38:  MOVFF  60,D1
0B3C:  MOVFF  5F,D0
0B40:  MOVFF  5E,CF
0B44:  RCALL  079E
0B46:  MOVFF  00,34
.................... } 
0B4A:  GOTO   2542 (RETURN)
....................  
.................... void SendToPC(void) 
.................... { 
....................    unsigned int32 pg; 
....................  
....................    for(pg=0;pg<(StopAddr);pg++) 
....................    { 
....................       SendPage(pg,EEP0); 
....................       SendPage(pg,EEP1); 
....................    } 
.................... } 
....................  
.................... //////////////////////////// Read and Send Record of a Test /////////////////// 
.................... void ReadRec(unsigned int32 Test) 
.................... { 
....................    unsigned int32 TA; 
....................    Sel_UART(FPGA);// 
*
1F64:  MOVLB  1
1F66:  CLRF   xA1
1F68:  MOVLB  0
1F6A:  RCALL  1916
....................    //status sel spi uc 
....................    SendCmd(CMD_STATUS | EEP0 | SPI_PIC | status); 
1F6C:  MOVFF  20,9D
1F70:  MOVF   21,W
1F72:  IORLW  01
1F74:  MOVWF  x9E
1F76:  MOVFF  22,9F
1F7A:  MOVF   23,W
1F7C:  IORLW  0C
1F7E:  MOVWF  xA0
1F80:  MOVFF  FE8,1A8
1F84:  MOVFF  22,1A7
1F88:  MOVFF  9E,1A6
1F8C:  MOVFF  20,1A5
1F90:  CALL   0B4E
....................         
....................    TA = (Test*10) + 0x3ff000; //last sector 
1F94:  MOVFF  98,A0
1F98:  MOVFF  97,9F
1F9C:  MOVFF  96,9E
1FA0:  MOVFF  95,9D
1FA4:  CLRF   xA4
1FA6:  CLRF   xA3
1FA8:  CLRF   xA2
1FAA:  MOVLW  0A
1FAC:  MOVWF  xA1
1FAE:  CALL   074A
1FB2:  MOVFF  00,99
1FB6:  MOVLW  F0
1FB8:  ADDWF  01,W
1FBA:  MOVWF  x9A
1FBC:  MOVLW  3F
1FBE:  ADDWFC 02,W
1FC0:  MOVWF  x9B
1FC2:  MOVLW  00
1FC4:  ADDWFC 03,W
1FC6:  MOVWF  x9C
....................  
....................    //Read  
....................    output_low(CSu); 
1FC8:  BCF    F94.1
1FCA:  BCF    F8B.1
....................    spi_write(3);//read cmd 
1FCC:  MOVF   FC9,W
1FCE:  MOVLW  03
1FD0:  MOVWF  FC9
1FD2:  RRCF   FC7,W
1FD4:  BNC   1FD2
....................    spi_write((TA>>16)&0xff);//addres 
1FD6:  MOVFF  9B,9E
1FDA:  MOVFF  9C,9F
1FDE:  CLRF   xA0
1FE0:  CLRF   xA1
1FE2:  CLRF   x9F
1FE4:  CLRF   xA0
1FE6:  CLRF   xA1
1FE8:  MOVF   FC9,W
1FEA:  MOVFF  9B,FC9
1FEE:  RRCF   FC7,W
1FF0:  BNC   1FEE
....................    spi_write((TA>>8)&0xff); 
1FF2:  MOVFF  9A,9E
1FF6:  MOVFF  9B,9F
1FFA:  MOVFF  9C,A0
1FFE:  CLRF   xA1
2000:  CLRF   x9F
2002:  CLRF   xA0
2004:  CLRF   xA1
2006:  MOVF   FC9,W
2008:  MOVFF  9A,FC9
200C:  RRCF   FC7,W
200E:  BNC   200C
....................    spi_write(TA&0xff); 
2010:  MOVFF  99,9D
2014:  CLRF   x9E
2016:  CLRF   x9F
2018:  CLRF   xA0
201A:  MOVF   FC9,W
201C:  MOVFF  99,FC9
2020:  RRCF   FC7,W
2022:  BNC   2020
....................     
....................    TA = spi_read(0);                      // 0: Test ID 
2024:  MOVF   FC9,W
2026:  CLRF   FC9
2028:  RRCF   FC7,W
202A:  BNC   2028
202C:  CLRF   x9C
202E:  CLRF   x9B
2030:  CLRF   x9A
2032:  MOVFF  FC9,99
....................     
....................    TA = spi_read(0);                      // 1: StartAddr MSB 
2036:  MOVF   FC9,W
2038:  CLRF   FC9
203A:  RRCF   FC7,W
203C:  BNC   203A
203E:  CLRF   x9C
2040:  CLRF   x9B
2042:  CLRF   x9A
2044:  MOVFF  FC9,99
....................    TA = (TA<<8) + spi_read(0);      // 2:  
2048:  MOVFF  9B,A1
204C:  MOVFF  9A,A0
2050:  MOVFF  99,9F
2054:  CLRF   x9E
2056:  MOVF   FC9,W
2058:  CLRF   FC9
205A:  RRCF   FC7,W
205C:  BNC   205A
205E:  MOVF   FC9,W
2060:  ADDWF  x9E,W
2062:  MOVWF  x99
2064:  MOVLW  00
2066:  ADDWFC x9F,W
2068:  MOVWF  x9A
206A:  MOVLW  00
206C:  ADDWFC xA0,W
206E:  MOVWF  x9B
2070:  MOVLW  00
2072:  ADDWFC xA1,W
2074:  MOVWF  x9C
....................    TA = (TA<<8) + spi_read(0);      // 3: StartAddr LSB 
2076:  MOVFF  9B,A1
207A:  MOVFF  9A,A0
207E:  MOVFF  99,9F
2082:  CLRF   x9E
2084:  MOVF   FC9,W
2086:  CLRF   FC9
2088:  RRCF   FC7,W
208A:  BNC   2088
208C:  MOVF   FC9,W
208E:  ADDWF  x9E,W
2090:  MOVWF  x99
2092:  MOVLW  00
2094:  ADDWFC x9F,W
2096:  MOVWF  x9A
2098:  MOVLW  00
209A:  ADDWFC xA0,W
209C:  MOVWF  x9B
209E:  MOVLW  00
20A0:  ADDWFC xA1,W
20A2:  MOVWF  x9C
....................    RecStartAddr = TA; 
20A4:  MOVFF  9C,59
20A8:  MOVFF  9B,58
20AC:  MOVFF  9A,57
20B0:  MOVFF  99,56
....................     
....................    TA = spi_read(0);                      // 4: StopAddr MSB 
20B4:  MOVF   FC9,W
20B6:  CLRF   FC9
20B8:  RRCF   FC7,W
20BA:  BNC   20B8
20BC:  CLRF   x9C
20BE:  CLRF   x9B
20C0:  CLRF   x9A
20C2:  MOVFF  FC9,99
....................    TA = (TA<<8) + spi_read(0);      // 5:  
20C6:  MOVFF  9B,A1
20CA:  MOVFF  9A,A0
20CE:  MOVFF  99,9F
20D2:  CLRF   x9E
20D4:  MOVF   FC9,W
20D6:  CLRF   FC9
20D8:  RRCF   FC7,W
20DA:  BNC   20D8
20DC:  MOVF   FC9,W
20DE:  ADDWF  x9E,W
20E0:  MOVWF  x99
20E2:  MOVLW  00
20E4:  ADDWFC x9F,W
20E6:  MOVWF  x9A
20E8:  MOVLW  00
20EA:  ADDWFC xA0,W
20EC:  MOVWF  x9B
20EE:  MOVLW  00
20F0:  ADDWFC xA1,W
20F2:  MOVWF  x9C
....................    TA = (TA<<8) + spi_read(0);      // 6: StopAddr LSB 
20F4:  MOVFF  9B,A1
20F8:  MOVFF  9A,A0
20FC:  MOVFF  99,9F
2100:  CLRF   x9E
2102:  MOVF   FC9,W
2104:  CLRF   FC9
2106:  RRCF   FC7,W
2108:  BNC   2106
210A:  MOVF   FC9,W
210C:  ADDWF  x9E,W
210E:  MOVWF  x99
2110:  MOVLW  00
2112:  ADDWFC x9F,W
2114:  MOVWF  x9A
2116:  MOVLW  00
2118:  ADDWFC xA0,W
211A:  MOVWF  x9B
211C:  MOVLW  00
211E:  ADDWFC xA1,W
2120:  MOVWF  x9C
....................    RecStopAddr = TA; 
2122:  MOVFF  9C,5D
2126:  MOVFF  9B,5C
212A:  MOVFF  9A,5B
212E:  MOVFF  99,5A
....................     
....................    TA = spi_read(0);                         // 7: Status MSB 
2132:  MOVF   FC9,W
2134:  CLRF   FC9
2136:  RRCF   FC7,W
2138:  BNC   2136
213A:  CLRF   x9C
213C:  CLRF   x9B
213E:  CLRF   x9A
2140:  MOVFF  FC9,99
....................    TA = (TA<<8) + spi_read(0);        // 8:  
2144:  MOVFF  9B,A1
2148:  MOVFF  9A,A0
214C:  MOVFF  99,9F
2150:  CLRF   x9E
2152:  MOVF   FC9,W
2154:  CLRF   FC9
2156:  RRCF   FC7,W
2158:  BNC   2156
215A:  MOVF   FC9,W
215C:  ADDWF  x9E,W
215E:  MOVWF  x99
2160:  MOVLW  00
2162:  ADDWFC x9F,W
2164:  MOVWF  x9A
2166:  MOVLW  00
2168:  ADDWFC xA0,W
216A:  MOVWF  x9B
216C:  MOVLW  00
216E:  ADDWFC xA1,W
2170:  MOVWF  x9C
....................    TA = (TA<<8) + spi_read(0);       // 9: Status LSB 
2172:  MOVFF  9B,A1
2176:  MOVFF  9A,A0
217A:  MOVFF  99,9F
217E:  CLRF   x9E
2180:  MOVF   FC9,W
2182:  CLRF   FC9
2184:  RRCF   FC7,W
2186:  BNC   2184
2188:  MOVF   FC9,W
218A:  ADDWF  x9E,W
218C:  MOVWF  x99
218E:  MOVLW  00
2190:  ADDWFC x9F,W
2192:  MOVWF  x9A
2194:  MOVLW  00
2196:  ADDWFC xA0,W
2198:  MOVWF  x9B
219A:  MOVLW  00
219C:  ADDWFC xA1,W
219E:  MOVWF  x9C
....................     
....................    output_high(CSu); 
21A0:  BCF    F94.1
21A2:  BSF    F8B.1
....................    delay_ms(20); 
21A4:  MOVLW  14
21A6:  MOVLB  1
21A8:  MOVWF  xAA
21AA:  MOVLB  0
21AC:  CALL   06E4
....................     
....................    Sel_UART(PC); 
21B0:  MOVLW  01
21B2:  MOVLB  1
21B4:  MOVWF  xA1
21B6:  MOVLB  0
21B8:  CALL   1916
....................    SendCmd(CMD_START | RecStartAddr); 
21BC:  MOVFF  56,9D
21C0:  MOVFF  57,9E
21C4:  MOVFF  58,9F
21C8:  MOVF   59,W
21CA:  IORLW  08
21CC:  MOVWF  xA0
21CE:  MOVFF  FE8,1A8
21D2:  MOVFF  58,1A7
21D6:  MOVFF  57,1A6
21DA:  MOVFF  56,1A5
21DE:  CALL   0B4E
....................    SendCmd(CMD_STOP | RecStopAddr); 
21E2:  MOVFF  5A,9D
21E6:  MOVFF  5B,9E
21EA:  MOVFF  5C,9F
21EE:  MOVF   5D,W
21F0:  IORLW  0A
21F2:  MOVWF  xA0
21F4:  MOVFF  FE8,1A8
21F8:  MOVFF  5C,1A7
21FC:  MOVFF  5B,1A6
2200:  MOVFF  5A,1A5
2204:  CALL   0B4E
....................    SendCmd(CMD_STATUS | TA); 
2208:  MOVFF  99,9D
220C:  MOVFF  9A,9E
2210:  MOVFF  9B,9F
2214:  MOVF   x9C,W
2216:  IORLW  0C
2218:  MOVWF  xA0
221A:  MOVFF  FE8,1A8
221E:  MOVFF  9B,1A7
2222:  MOVFF  9A,1A6
2226:  MOVFF  99,1A5
222A:  CALL   0B4E
.................... } 
222E:  RETLW  00
....................  
.................... /////////////////// Read a Page from EEPROM and Send to PC ///////////////// 
.................... void SendPage(unsigned int32 G, unsigned int32 EEPROM) 
.................... { 
....................    unsigned char AA[256]; 
....................    unsigned int32 k; 
....................     
....................    Sel_UART(FPGA); 
*
193C:  MOVLB  1
193E:  CLRF   xA1
1940:  MOVLB  0
1942:  RCALL  1916
....................  
....................    //Switch EEPROM 
....................    SendCmd(CMD_STATUS | EEPROM | SPI_PIC | status); 
1944:  MOVFF  99,1A1
1948:  MOVFF  9A,1A2
194C:  MOVFF  9B,1A3
1950:  MOVLB  0
1952:  MOVF   x9C,W
1954:  IORLW  0C
1956:  MOVLB  1
1958:  MOVWF  xA4
195A:  BSF    xA2.0
195C:  MOVF   20,W
195E:  IORWF  xA1,F
1960:  MOVF   21,W
1962:  IORWF  xA2,F
1964:  MOVF   22,W
1966:  IORWF  xA3,F
1968:  MOVF   23,W
196A:  IORWF  xA4,F
196C:  MOVFF  1A4,1A8
1970:  MOVFF  1A3,1A7
1974:  MOVFF  1A2,1A6
1978:  MOVFF  1A1,1A5
197C:  MOVLB  0
197E:  CALL   0B4E
....................     
....................    //Read 
....................    output_low(CSu); 
1982:  BCF    F94.1
1984:  BCF    F8B.1
....................    spi_write(3);//read command  
1986:  MOVF   FC9,W
1988:  MOVLW  03
198A:  MOVWF  FC9
198C:  RRCF   FC7,W
198E:  BNC   198C
....................    spi_write((G>>8)&0xff); 
1990:  MOVFF  96,1A2
1994:  MOVFF  97,1A3
1998:  MOVFF  98,1A4
199C:  MOVLB  1
199E:  CLRF   xA5
19A0:  CLRF   xA3
19A2:  CLRF   xA4
19A4:  CLRF   xA5
19A6:  MOVF   FC9,W
19A8:  MOVFF  96,FC9
19AC:  RRCF   FC7,W
19AE:  BNC   19AC
....................    spi_write(G&0xff); 
19B0:  MOVFF  95,1A1
19B4:  MOVLB  1
19B6:  CLRF   xA2
19B8:  CLRF   xA3
19BA:  CLRF   xA4
19BC:  MOVF   FC9,W
19BE:  MOVFF  95,FC9
19C2:  RRCF   FC7,W
19C4:  BNC   19C2
....................    spi_write(0); 
19C6:  MOVF   FC9,W
19C8:  CLRF   FC9
19CA:  RRCF   FC7,W
19CC:  BNC   19CA
....................    for(k=0;k<256;k++) 
19CE:  CLRF   xA0
19D0:  CLRF   x9F
19D2:  CLRF   x9E
19D4:  CLRF   x9D
19D6:  MOVF   xA0,F
19D8:  BNZ   1A0E
19DA:  MOVF   x9F,F
19DC:  BNZ   1A0E
19DE:  MOVF   x9E,W
19E0:  SUBLW  00
19E2:  BNC   1A0E
....................       AA[k] = spi_read(0); 
19E4:  MOVLW  9D
19E6:  ADDWF  x9D,W
19E8:  MOVWF  FE9
19EA:  MOVLW  00
19EC:  ADDWFC x9E,W
19EE:  MOVWF  FEA
19F0:  MOVF   FC9,W
19F2:  CLRF   FC9
19F4:  RRCF   FC7,W
19F6:  BNC   19F4
19F8:  MOVFF  FC9,FEF
19FC:  MOVLW  01
19FE:  ADDWF  x9D,F
1A00:  BTFSC  FD8.0
1A02:  INCF   x9E,F
1A04:  BTFSC  FD8.2
1A06:  INCF   x9F,F
1A08:  BTFSC  FD8.2
1A0A:  INCF   xA0,F
1A0C:  BRA    19D6
....................    output_high(CSu); 
1A0E:  BCF    F94.1
1A10:  BSF    F8B.1
....................     
....................    //status sel spi FPGA 
....................    //SendCmd(CMD_STATUS | EEPROM | SPI_FPGA | status); 
....................     
....................    // Switch to PC UART again 
....................    Sel_UART(PC); 
1A12:  MOVLW  01
1A14:  MOVWF  xA1
1A16:  MOVLB  0
1A18:  RCALL  1916
....................     
....................    for(k=0;k<256;k++) 
1A1A:  MOVLB  1
1A1C:  CLRF   xA0
1A1E:  CLRF   x9F
1A20:  CLRF   x9E
1A22:  CLRF   x9D
1A24:  MOVF   xA0,F
1A26:  BNZ   1A60
1A28:  MOVF   x9F,F
1A2A:  BNZ   1A60
1A2C:  MOVF   x9E,W
1A2E:  SUBLW  00
1A30:  BNC   1A60
....................       printf("%c",AA[k]);//printf("%2X",AA[k]); 
1A32:  MOVLW  9D
1A34:  ADDWF  x9D,W
1A36:  MOVWF  FE9
1A38:  MOVLW  00
1A3A:  ADDWFC x9E,W
1A3C:  MOVWF  FEA
1A3E:  MOVFF  FEF,1A1
1A42:  MOVFF  1A1,1AA
1A46:  MOVLB  0
1A48:  CALL   070C
1A4C:  MOVLW  01
1A4E:  MOVLB  1
1A50:  ADDWF  x9D,F
1A52:  BTFSC  FD8.0
1A54:  INCF   x9E,F
1A56:  BTFSC  FD8.2
1A58:  INCF   x9F,F
1A5A:  BTFSC  FD8.2
1A5C:  INCF   xA0,F
1A5E:  BRA    1A24
.................... } 
1A60:  MOVLB  0
1A62:  RETLW  00
....................  
.................... ///////////////////// Acquire Data from the ADC via FPGA  ///////////////////// 
.................... void Acquire(void) 
.................... { 
....................    //default UART = FPGA 
....................  
....................    Sel_UART(FPGA); 
*
1C66:  MOVLB  1
1C68:  CLRF   xA1
1C6A:  MOVLB  0
1C6C:  RCALL  1916
....................  
....................    //status sel spi FPGA 
....................    SendCmd(CMD_STATUS | EEP0 | SPI_FPGA | status); 
1C6E:  MOVFF  20,95
1C72:  MOVFF  21,96
1C76:  MOVFF  22,97
1C7A:  MOVF   23,W
1C7C:  IORLW  0C
1C7E:  MOVWF  x98
1C80:  MOVFF  FE8,1A8
1C84:  MOVFF  22,1A7
1C88:  MOVFF  21,1A6
1C8C:  MOVFF  20,1A5
1C90:  CALL   0B4E
....................     
....................    //reload last stop address from mem 
....................    //start address 
....................    StartAddr = read_eeprom(5); 
1C94:  MOVFF  FF2,95
1C98:  BCF    FF2.7
1C9A:  MOVLW  05
1C9C:  MOVWF  FA9
1C9E:  BCF    FA6.6
1CA0:  BCF    FA6.7
1CA2:  BSF    FA6.0
1CA4:  MOVF   FA8,W
1CA6:  BTFSC  x95.7
1CA8:  BSF    FF2.7
1CAA:  CLRF   55
1CAC:  CLRF   54
1CAE:  CLRF   53
1CB0:  MOVWF  52
....................    StartAddr = (StartAddr<<8) + read_eeprom(4); 
1CB2:  MOVFF  54,99
1CB6:  MOVFF  53,98
1CBA:  MOVFF  52,97
1CBE:  CLRF   x96
1CC0:  MOVFF  FF2,9A
1CC4:  BCF    FF2.7
1CC6:  MOVLW  04
1CC8:  MOVWF  FA9
1CCA:  BCF    FA6.6
1CCC:  BCF    FA6.7
1CCE:  BSF    FA6.0
1CD0:  MOVF   FA8,W
1CD2:  BTFSC  x9A.7
1CD4:  BSF    FF2.7
1CD6:  ADDWF  x96,W
1CD8:  MOVWF  52
1CDA:  MOVLW  00
1CDC:  ADDWFC x97,W
1CDE:  MOVWF  53
1CE0:  MOVLW  00
1CE2:  ADDWFC x98,W
1CE4:  MOVWF  54
1CE6:  MOVLW  00
1CE8:  ADDWFC x99,W
1CEA:  MOVWF  55
....................    StartAddr = (StartAddr<<8) + read_eeprom(3); 
1CEC:  MOVFF  54,99
1CF0:  MOVFF  53,98
1CF4:  MOVFF  52,97
1CF8:  CLRF   x96
1CFA:  MOVFF  FF2,9A
1CFE:  BCF    FF2.7
1D00:  MOVLW  03
1D02:  MOVWF  FA9
1D04:  BCF    FA6.6
1D06:  BCF    FA6.7
1D08:  BSF    FA6.0
1D0A:  MOVF   FA8,W
1D0C:  BTFSC  x9A.7
1D0E:  BSF    FF2.7
1D10:  ADDWF  x96,W
1D12:  MOVWF  52
1D14:  MOVLW  00
1D16:  ADDWFC x97,W
1D18:  MOVWF  53
1D1A:  MOVLW  00
1D1C:  ADDWFC x98,W
1D1E:  MOVWF  54
1D20:  MOVLW  00
1D22:  ADDWFC x99,W
1D24:  MOVWF  55
....................    SendCmd(CMD_START | StartAddr); 
1D26:  MOVFF  52,95
1D2A:  MOVFF  53,96
1D2E:  MOVFF  54,97
1D32:  MOVF   55,W
1D34:  IORLW  08
1D36:  MOVWF  x98
1D38:  MOVFF  FE8,1A8
1D3C:  MOVFF  54,1A7
1D40:  MOVFF  53,1A6
1D44:  MOVFF  52,1A5
1D48:  CALL   0B4E
....................     
....................    //stop address 
....................    StopAddr = (unsigned int32) (R*4);//7 
1D4C:  MOVF   36,W
1D4E:  MULLW  04
1D50:  MOVF   FF3,W
1D52:  CLRF   51
1D54:  CLRF   50
1D56:  CLRF   4F
1D58:  MOVWF  4E
....................    StopAddr = StopAddr *  T; 
1D5A:  MOVFF  51,A0
1D5E:  MOVFF  50,9F
1D62:  MOVFF  4F,9E
1D66:  MOVFF  4E,9D
1D6A:  CLRF   xA4
1D6C:  CLRF   xA3
1D6E:  MOVFF  2F,A2
1D72:  MOVFF  2E,A1
1D76:  CALL   074A
1D7A:  MOVFF  03,51
1D7E:  MOVFF  02,50
1D82:  MOVFF  01,4F
1D86:  MOVFF  00,4E
....................    StopAddr = StartAddr + StopAddr; 
1D8A:  MOVF   52,W
1D8C:  ADDWF  4E,F
1D8E:  MOVF   53,W
1D90:  ADDWFC 4F,F
1D92:  MOVF   54,W
1D94:  ADDWFC 50,F
1D96:  MOVF   55,W
1D98:  ADDWFC 51,F
....................  
....................    SendCmd((CMD_STOP | StopAddr)-1); 
1D9A:  MOVFF  4E,95
1D9E:  MOVFF  4F,96
1DA2:  MOVFF  50,97
1DA6:  MOVF   51,W
1DA8:  IORLW  0A
1DAA:  MOVWF  x98
1DAC:  MOVLW  01
1DAE:  SUBWF  x95,F
1DB0:  MOVLW  00
1DB2:  SUBWFB x96,F
1DB4:  SUBWFB x97,F
1DB6:  SUBWFB x98,F
1DB8:  MOVFF  98,1A8
1DBC:  MOVFF  97,1A7
1DC0:  MOVFF  96,1A6
1DC4:  MOVFF  95,1A5
1DC8:  CALL   0B4E
....................     
....................   
....................  
....................     
....................    //generate START of experiment 
....................    output_high(START); 
1DCC:  BCF    F93.1
1DCE:  BSF    F8A.1
....................    delay_us(1);//10 
1DD0:  BRA    1DD2
....................    output_low(START); 
1DD2:  BCF    F93.1
1DD4:  BCF    F8A.1
....................  
....................    while(DONE==0); 
....................    //Finished, now update Test ID, and save stop address for next page 
....................    M = ((TOT-(StopAddr))*100)/TOT; 
1DD6:  MOVF   4E,W
1DD8:  SUBWF  5E,W
1DDA:  MOVWF  x95
1DDC:  MOVF   4F,W
1DDE:  SUBWFB 5F,W
1DE0:  MOVWF  x96
1DE2:  MOVF   50,W
1DE4:  SUBWFB x60,W
1DE6:  MOVWF  x97
1DE8:  MOVF   51,W
1DEA:  SUBWFB x61,W
1DEC:  MOVWF  x98
1DEE:  MOVWF  xA0
1DF0:  MOVFF  97,9F
1DF4:  MOVFF  96,9E
1DF8:  MOVFF  95,9D
1DFC:  CLRF   xA4
1DFE:  CLRF   xA3
1E00:  CLRF   xA2
1E02:  MOVLW  64
1E04:  MOVWF  xA1
1E06:  CALL   074A
1E0A:  MOVFF  03,98
1E0E:  MOVFF  02,97
1E12:  MOVFF  01,96
1E16:  MOVFF  00,95
1E1A:  MOVFF  03,CE
1E1E:  MOVFF  02,CD
1E22:  MOVFF  01,CC
1E26:  MOVFF  00,CB
1E2A:  MOVFF  61,D2
1E2E:  MOVFF  60,D1
1E32:  MOVFF  5F,D0
1E36:  MOVFF  5E,CF
1E3A:  CALL   079E
1E3E:  MOVFF  00,34
....................    SaveRec(Tid); 
1E42:  MOVFF  29,98
1E46:  MOVFF  28,97
1E4A:  MOVFF  27,96
1E4E:  MOVFF  26,95
1E52:  BRA    1A64
....................    // Save in local memory 
....................    Tid++; 
1E54:  MOVLW  01
1E56:  ADDWF  26,F
1E58:  BTFSC  FD8.0
1E5A:  INCF   27,F
1E5C:  BTFSC  FD8.2
1E5E:  INCF   28,F
1E60:  BTFSC  FD8.2
1E62:  INCF   29,F
....................    write_eeprom(2,(Tid)&0xff); 
1E64:  MOVF   26,W
1E66:  MOVWF  x95
1E68:  CLRF   x96
1E6A:  CLRF   x97
1E6C:  CLRF   x98
1E6E:  MOVLW  02
1E70:  MOVWF  FA9
1E72:  MOVFF  95,FA8
1E76:  BCF    FA6.6
1E78:  BCF    FA6.7
1E7A:  BSF    FA6.2
1E7C:  MOVF   FF2,W
1E7E:  MOVWF  00
1E80:  BCF    FF2.7
1E82:  MOVLB  F
1E84:  MOVLW  55
1E86:  MOVWF  FA7
1E88:  MOVLW  AA
1E8A:  MOVWF  FA7
1E8C:  BSF    FA6.1
1E8E:  MOVF   00,W
1E90:  IORWF  FF2,F
1E92:  BTFSC  FA6.1
1E94:  BRA    1E92
1E96:  BCF    FA6.2
....................    write_eeprom(3,StopAddr&0xff); 
1E98:  MOVF   4E,W
1E9A:  MOVLB  0
1E9C:  MOVWF  x95
1E9E:  CLRF   x96
1EA0:  CLRF   x97
1EA2:  CLRF   x98
1EA4:  MOVLW  03
1EA6:  MOVWF  FA9
1EA8:  MOVFF  95,FA8
1EAC:  BCF    FA6.6
1EAE:  BCF    FA6.7
1EB0:  BSF    FA6.2
1EB2:  MOVF   FF2,W
1EB4:  MOVWF  00
1EB6:  BCF    FF2.7
1EB8:  MOVLB  F
1EBA:  MOVLW  55
1EBC:  MOVWF  FA7
1EBE:  MOVLW  AA
1EC0:  MOVWF  FA7
1EC2:  BSF    FA6.1
1EC4:  MOVF   00,W
1EC6:  IORWF  FF2,F
1EC8:  BTFSC  FA6.1
1ECA:  BRA    1EC8
1ECC:  BCF    FA6.2
....................    write_eeprom(4,(StopAddr>>8)&0xff); 
1ECE:  MOVFF  4F,96
1ED2:  MOVFF  50,97
1ED6:  MOVFF  51,98
1EDA:  MOVLB  0
1EDC:  CLRF   x99
1EDE:  CLRF   x97
1EE0:  CLRF   x98
1EE2:  CLRF   x99
1EE4:  MOVLW  04
1EE6:  MOVWF  FA9
1EE8:  MOVFF  96,FA8
1EEC:  BCF    FA6.6
1EEE:  BCF    FA6.7
1EF0:  BSF    FA6.2
1EF2:  MOVF   FF2,W
1EF4:  MOVWF  00
1EF6:  BCF    FF2.7
1EF8:  MOVLB  F
1EFA:  MOVLW  55
1EFC:  MOVWF  FA7
1EFE:  MOVLW  AA
1F00:  MOVWF  FA7
1F02:  BSF    FA6.1
1F04:  MOVF   00,W
1F06:  IORWF  FF2,F
1F08:  BTFSC  FA6.1
1F0A:  BRA    1F08
1F0C:  BCF    FA6.2
....................    write_eeprom(5,(StopAddr>>16)&0xff); 
1F0E:  MOVFF  50,96
1F12:  MOVFF  51,97
1F16:  MOVLB  0
1F18:  CLRF   x98
1F1A:  CLRF   x99
1F1C:  CLRF   x97
1F1E:  CLRF   x98
1F20:  CLRF   x99
1F22:  MOVLW  05
1F24:  MOVWF  FA9
1F26:  MOVFF  96,FA8
1F2A:  BCF    FA6.6
1F2C:  BCF    FA6.7
1F2E:  BSF    FA6.2
1F30:  MOVF   FF2,W
1F32:  MOVWF  00
1F34:  BCF    FF2.7
1F36:  MOVLB  F
1F38:  MOVLW  55
1F3A:  MOVWF  FA7
1F3C:  MOVLW  AA
1F3E:  MOVWF  FA7
1F40:  BSF    FA6.1
1F42:  MOVF   00,W
1F44:  IORWF  FF2,F
1F46:  BTFSC  FA6.1
1F48:  BRA    1F46
1F4A:  BCF    FA6.2
....................  
.................... } 
1F4C:  MOVLB  0
1F4E:  GOTO   343C (RETURN)
.................... ////////////////////// Save Record for a Test  /////////////////////////////// 
.................... void SaveRec(unsigned int32 Test) 
.................... { 
....................    unsigned int32 TA; 
....................    //SPI_PIC 
....................    SendCmd(CMD_STATUS | EEP0 | SPI_PIC | status); 
*
1A64:  MOVF   20,W
1A66:  MOVWF  x9D
1A68:  MOVF   21,W
1A6A:  IORLW  01
1A6C:  MOVWF  x9E
1A6E:  MOVFF  22,9F
1A72:  MOVF   23,W
1A74:  IORLW  0C
1A76:  MOVWF  xA0
1A78:  MOVFF  FE8,1A8
1A7C:  MOVFF  22,1A7
1A80:  MOVFF  9E,1A6
1A84:  MOVFF  9D,1A5
1A88:  CALL   0B4E
....................     
....................    TA = (Test*10) + 0x3ff000; //last sector 
1A8C:  MOVFF  98,A0
1A90:  MOVFF  97,9F
1A94:  MOVFF  96,9E
1A98:  MOVFF  95,9D
1A9C:  CLRF   xA4
1A9E:  CLRF   xA3
1AA0:  CLRF   xA2
1AA2:  MOVLW  0A
1AA4:  MOVWF  xA1
1AA6:  CALL   074A
1AAA:  MOVFF  00,99
1AAE:  MOVLW  F0
1AB0:  ADDWF  01,W
1AB2:  MOVWF  x9A
1AB4:  MOVLW  3F
1AB6:  ADDWFC 02,W
1AB8:  MOVWF  x9B
1ABA:  MOVLW  00
1ABC:  ADDWFC 03,W
1ABE:  MOVWF  x9C
....................    //enable 
....................    output_low(CSu); 
1AC0:  BCF    F94.1
1AC2:  BCF    F8B.1
....................    spi_write(6); 
1AC4:  MOVF   FC9,W
1AC6:  MOVLW  06
1AC8:  MOVWF  FC9
1ACA:  RRCF   FC7,W
1ACC:  BNC   1ACA
....................    output_high(CSu); 
1ACE:  BCF    F94.1
1AD0:  BSF    F8B.1
....................    delay_ms(1); 
1AD2:  MOVLW  01
1AD4:  MOVLB  1
1AD6:  MOVWF  xAA
1AD8:  MOVLB  0
1ADA:  CALL   06E4
....................     
....................    //write  
....................    output_low(CSu); 
1ADE:  BCF    F94.1
1AE0:  BCF    F8B.1
....................    spi_write(2);//write cmd 
1AE2:  MOVF   FC9,W
1AE4:  MOVLW  02
1AE6:  MOVWF  FC9
1AE8:  RRCF   FC7,W
1AEA:  BNC   1AE8
....................    spi_write((TA>>16)&0xff);//addres 
1AEC:  MOVFF  9B,9E
1AF0:  MOVFF  9C,9F
1AF4:  CLRF   xA0
1AF6:  CLRF   xA1
1AF8:  CLRF   x9F
1AFA:  CLRF   xA0
1AFC:  CLRF   xA1
1AFE:  MOVF   FC9,W
1B00:  MOVFF  9B,FC9
1B04:  RRCF   FC7,W
1B06:  BNC   1B04
....................    spi_write((TA>>8)&0xff); 
1B08:  MOVFF  9A,9E
1B0C:  MOVFF  9B,9F
1B10:  MOVFF  9C,A0
1B14:  CLRF   xA1
1B16:  CLRF   x9F
1B18:  CLRF   xA0
1B1A:  CLRF   xA1
1B1C:  MOVF   FC9,W
1B1E:  MOVFF  9A,FC9
1B22:  RRCF   FC7,W
1B24:  BNC   1B22
....................    spi_write(TA&0xff); 
1B26:  MOVFF  99,9D
1B2A:  CLRF   x9E
1B2C:  CLRF   x9F
1B2E:  CLRF   xA0
1B30:  MOVF   FC9,W
1B32:  MOVFF  99,FC9
1B36:  RRCF   FC7,W
1B38:  BNC   1B36
....................    spi_write(Tid&0xff);                // 0: Test ID 
1B3A:  MOVFF  26,9D
1B3E:  CLRF   x9E
1B40:  CLRF   x9F
1B42:  CLRF   xA0
1B44:  MOVF   FC9,W
1B46:  MOVFF  26,FC9
1B4A:  RRCF   FC7,W
1B4C:  BNC   1B4A
....................    spi_write((StartAddr>>16)&0xff);     // 1: StartAddr MSB 
1B4E:  MOVFF  54,9E
1B52:  MOVFF  55,9F
1B56:  CLRF   xA0
1B58:  CLRF   xA1
1B5A:  CLRF   x9F
1B5C:  CLRF   xA0
1B5E:  CLRF   xA1
1B60:  MOVF   FC9,W
1B62:  MOVFF  54,FC9
1B66:  RRCF   FC7,W
1B68:  BNC   1B66
....................    spi_write((StartAddr>>8)&0xff);      // 2:  
1B6A:  MOVFF  53,9E
1B6E:  MOVFF  54,9F
1B72:  MOVFF  55,A0
1B76:  CLRF   xA1
1B78:  CLRF   x9F
1B7A:  CLRF   xA0
1B7C:  CLRF   xA1
1B7E:  MOVF   FC9,W
1B80:  MOVFF  53,FC9
1B84:  RRCF   FC7,W
1B86:  BNC   1B84
....................    spi_write(StartAddr&0xff);           // 3: StartAddr LSB 
1B88:  MOVFF  52,9D
1B8C:  CLRF   x9E
1B8E:  CLRF   x9F
1B90:  CLRF   xA0
1B92:  MOVF   FC9,W
1B94:  MOVFF  52,FC9
1B98:  RRCF   FC7,W
1B9A:  BNC   1B98
....................    spi_write((StopAddr>>16)&0xff);         // 4: StopAddr SB 
1B9C:  MOVFF  50,9E
1BA0:  MOVFF  51,9F
1BA4:  CLRF   xA0
1BA6:  CLRF   xA1
1BA8:  CLRF   x9F
1BAA:  CLRF   xA0
1BAC:  CLRF   xA1
1BAE:  MOVF   FC9,W
1BB0:  MOVFF  50,FC9
1BB4:  RRCF   FC7,W
1BB6:  BNC   1BB4
....................    spi_write((StopAddr>>8)&0xff);      // 5:  
1BB8:  MOVFF  4F,9E
1BBC:  MOVFF  50,9F
1BC0:  MOVFF  51,A0
1BC4:  CLRF   xA1
1BC6:  CLRF   x9F
1BC8:  CLRF   xA0
1BCA:  CLRF   xA1
1BCC:  MOVF   FC9,W
1BCE:  MOVFF  4F,FC9
1BD2:  RRCF   FC7,W
1BD4:  BNC   1BD2
....................    spi_write(StopAddr&0xff);           // 6: StopAddr MSB 
1BD6:  MOVFF  4E,9D
1BDA:  CLRF   x9E
1BDC:  CLRF   x9F
1BDE:  CLRF   xA0
1BE0:  MOVF   FC9,W
1BE2:  MOVFF  4E,FC9
1BE6:  RRCF   FC7,W
1BE8:  BNC   1BE6
....................    spi_write((Status>>16)&0xff);           // 7: Status LSB 
1BEA:  MOVFF  22,9E
1BEE:  MOVFF  23,9F
1BF2:  CLRF   xA0
1BF4:  CLRF   xA1
1BF6:  CLRF   x9F
1BF8:  CLRF   xA0
1BFA:  CLRF   xA1
1BFC:  MOVF   FC9,W
1BFE:  MOVFF  22,FC9
1C02:  RRCF   FC7,W
1C04:  BNC   1C02
....................    spi_write((Status>>8)&0xff);        // 8:  
1C06:  MOVFF  21,9E
1C0A:  MOVFF  22,9F
1C0E:  MOVFF  23,A0
1C12:  CLRF   xA1
1C14:  CLRF   x9F
1C16:  CLRF   xA0
1C18:  CLRF   xA1
1C1A:  MOVF   FC9,W
1C1C:  MOVFF  21,FC9
1C20:  RRCF   FC7,W
1C22:  BNC   1C20
....................    spi_write(Status&0xff);         // 9: Status MSB 
1C24:  MOVFF  20,9D
1C28:  CLRF   x9E
1C2A:  CLRF   x9F
1C2C:  CLRF   xA0
1C2E:  MOVF   FC9,W
1C30:  MOVFF  20,FC9
1C34:  RRCF   FC7,W
1C36:  BNC   1C34
....................     
....................    output_high(CSu); 
1C38:  BCF    F94.1
1C3A:  BSF    F8B.1
....................    //delay_ms(20); //PP Time 
....................     
....................    // status sel_spi FPGA 
....................    SendCmd(CMD_STATUS | EEP0 | SPI_FPGA | status); 
1C3C:  MOVFF  20,9D
1C40:  MOVFF  21,9E
1C44:  MOVFF  22,9F
1C48:  MOVF   23,W
1C4A:  IORLW  0C
1C4C:  MOVWF  xA0
1C4E:  MOVFF  FE8,1A8
1C52:  MOVFF  22,1A7
1C56:  MOVFF  21,1A6
1C5A:  MOVFF  20,1A5
1C5E:  CALL   0B4E
.................... } 
1C62:  GOTO   1E54 (RETURN)
.................... //////////////////////// EEPROM //////////////////////////////////////// 
.................... void EraseAll(void) 
.................... { 
....................    Tid =0; 
*
2262:  CLRF   29
2264:  CLRF   28
2266:  CLRF   27
2268:  CLRF   26
....................    StartAddr = 0; 
226A:  CLRF   55
226C:  CLRF   54
226E:  CLRF   53
2270:  CLRF   52
....................    //M = ((TOT-(StartAddr*2))*100)/TOT; 
....................    M = ((TOT-(StartAddr))*100)/TOT; 
2272:  MOVF   52,W
2274:  SUBWF  5E,W
2276:  MOVWF  x95
2278:  MOVF   53,W
227A:  SUBWFB 5F,W
227C:  MOVWF  x96
227E:  MOVF   54,W
2280:  SUBWFB x60,W
2282:  MOVWF  x97
2284:  MOVF   55,W
2286:  SUBWFB x61,W
2288:  MOVWF  x98
228A:  MOVWF  xA0
228C:  MOVFF  97,9F
2290:  MOVFF  96,9E
2294:  MOVFF  95,9D
2298:  CLRF   xA4
229A:  CLRF   xA3
229C:  CLRF   xA2
229E:  MOVLW  64
22A0:  MOVWF  xA1
22A2:  CALL   074A
22A6:  MOVFF  03,98
22AA:  MOVFF  02,97
22AE:  MOVFF  01,96
22B2:  MOVFF  00,95
22B6:  MOVFF  03,CE
22BA:  MOVFF  02,CD
22BE:  MOVFF  01,CC
22C2:  MOVFF  00,CB
22C6:  MOVFF  61,D2
22CA:  MOVFF  60,D1
22CE:  MOVFF  5F,D0
22D2:  MOVFF  5E,CF
22D6:  CALL   079E
22DA:  MOVFF  00,34
....................     
....................    write_eeprom(2,0);//Tid 
22DE:  MOVLW  02
22E0:  MOVWF  FA9
22E2:  CLRF   FA8
22E4:  BCF    FA6.6
22E6:  BCF    FA6.7
22E8:  BSF    FA6.2
22EA:  MOVF   FF2,W
22EC:  MOVWF  00
22EE:  BCF    FF2.7
22F0:  MOVLB  F
22F2:  MOVLW  55
22F4:  MOVWF  FA7
22F6:  MOVLW  AA
22F8:  MOVWF  FA7
22FA:  BSF    FA6.1
22FC:  MOVF   00,W
22FE:  IORWF  FF2,F
2300:  BTFSC  FA6.1
2302:  BRA    2300
2304:  BCF    FA6.2
....................    write_eeprom(3,0);//start address 
2306:  MOVLW  03
2308:  MOVWF  FA9
230A:  CLRF   FA8
230C:  BCF    FA6.6
230E:  BCF    FA6.7
2310:  BSF    FA6.2
2312:  MOVFF  FF2,00
2316:  BCF    FF2.7
2318:  MOVLW  55
231A:  MOVWF  FA7
231C:  MOVLW  AA
231E:  MOVWF  FA7
2320:  BSF    FA6.1
2322:  MOVF   00,W
2324:  IORWF  FF2,F
2326:  BTFSC  FA6.1
2328:  BRA    2326
232A:  BCF    FA6.2
....................    write_eeprom(4,0); 
232C:  MOVLW  04
232E:  MOVWF  FA9
2330:  CLRF   FA8
2332:  BCF    FA6.6
2334:  BCF    FA6.7
2336:  BSF    FA6.2
2338:  MOVFF  FF2,00
233C:  BCF    FF2.7
233E:  MOVLW  55
2340:  MOVWF  FA7
2342:  MOVLW  AA
2344:  MOVWF  FA7
2346:  BSF    FA6.1
2348:  MOVF   00,W
234A:  IORWF  FF2,F
234C:  BTFSC  FA6.1
234E:  BRA    234C
2350:  BCF    FA6.2
....................    write_eeprom(5,0); 
2352:  MOVLW  05
2354:  MOVWF  FA9
2356:  CLRF   FA8
2358:  BCF    FA6.6
235A:  BCF    FA6.7
235C:  BSF    FA6.2
235E:  MOVFF  FF2,00
2362:  BCF    FF2.7
2364:  MOVLW  55
2366:  MOVWF  FA7
2368:  MOVLW  AA
236A:  MOVWF  FA7
236C:  BSF    FA6.1
236E:  MOVF   00,W
2370:  IORWF  FF2,F
2372:  BTFSC  FA6.1
2374:  BRA    2372
2376:  BCF    FA6.2
....................     
....................    //status sel spi uc 
....................    SendCmd(CMD_STATUS | EEP0 | SPI_PIC | status); 
2378:  MOVFF  20,95
237C:  MOVLB  0
237E:  MOVF   21,W
2380:  IORLW  01
2382:  MOVWF  x96
2384:  MOVFF  22,97
2388:  MOVF   23,W
238A:  IORLW  0C
238C:  MOVWF  x98
238E:  MOVFF  FE8,1A8
2392:  MOVFF  22,1A7
2396:  MOVFF  96,1A6
239A:  MOVFF  20,1A5
239E:  CALL   0B4E
....................    EraseEE(); 
23A2:  RCALL  2230
....................    //status sel spi uc 
....................    SendCmd(CMD_STATUS | EEP1 | SPI_PIC | status); 
23A4:  MOVFF  20,95
23A8:  MOVF   21,W
23AA:  IORLW  03
23AC:  MOVWF  x96
23AE:  MOVFF  22,97
23B2:  MOVF   23,W
23B4:  IORLW  0C
23B6:  MOVWF  x98
23B8:  MOVFF  FE8,1A8
23BC:  MOVFF  22,1A7
23C0:  MOVFF  96,1A6
23C4:  MOVFF  20,1A5
23C8:  CALL   0B4E
....................    EraseEE(); 
23CC:  RCALL  2230
.................... /* 
....................    //status sel spi uc 
....................    SendCmd(CMD_STATUS | EEP2 | SPI_PIC | status); 
....................    EraseEE(); 
....................    //status sel spi uc 
....................    SendCmd(CMD_STATUS | EEP3 | SPI_PIC | status); 
....................    EraseEE(); 
....................     
.................... */ 
....................    delay_ms(35000); 
23CE:  MOVLW  8C
23D0:  MOVWF  x95
23D2:  MOVLW  FA
23D4:  MOVLB  1
23D6:  MOVWF  xAA
23D8:  MOVLB  0
23DA:  CALL   06E4
23DE:  DECFSZ x95,F
23E0:  BRA    23D2
....................    // status sel_spi FPGA 
....................    SendCmd(CMD_STATUS | EEP0 | SPI_FPGA | status); 
23E2:  MOVFF  20,95
23E6:  MOVFF  21,96
23EA:  MOVFF  22,97
23EE:  MOVF   23,W
23F0:  IORLW  0C
23F2:  MOVWF  x98
23F4:  MOVFF  FE8,1A8
23F8:  MOVFF  22,1A7
23FC:  MOVFF  21,1A6
2400:  MOVFF  20,1A5
2404:  CALL   0B4E
....................     
.................... } 
2408:  GOTO   36EA (RETURN)
....................  
.................... void EraseEE(void) 
.................... { 
....................     
....................    //enable 
....................    output_low(CSu); 
*
2230:  BCF    F94.1
2232:  BCF    F8B.1
....................    spi_write(6); 
2234:  MOVF   FC9,W
2236:  MOVLW  06
2238:  MOVWF  FC9
223A:  RRCF   FC7,W
223C:  BNC   223A
....................    output_high(CSu); 
223E:  BCF    F94.1
2240:  BSF    F8B.1
....................    delay_ms(1); 
2242:  MOVLW  01
2244:  MOVLB  1
2246:  MOVWF  xAA
2248:  MOVLB  0
224A:  CALL   06E4
....................     
....................    //chip erase 
....................    output_low(CSu); 
224E:  BCF    F94.1
2250:  BCF    F8B.1
....................    spi_write(0xc7); 
2252:  MOVF   FC9,W
2254:  MOVLW  C7
2256:  MOVWF  FC9
2258:  RRCF   FC7,W
225A:  BNC   2258
....................    /* 
....................    //block erase 
....................    output_low(CSu); 
....................    spi_write(0xd8); 
....................    spi_write(0); 
....................    spi_write(0); 
....................    spi_write(0); 
....................    */ 
....................    output_high(CSu); 
225C:  BCF    F94.1
225E:  BSF    F8B.1
....................    //delay_ms(2000); 
.................... } 
2260:  RETLW  00
....................  
....................  
.................... void WriteEE(unsigned char pp,unsigned int32 EEPROM) 
.................... { 
....................     
....................    unsigned int32 k; 
....................     
....................      //Switch EEPROM 
....................    SendCmd(CMD_STATUS | EEPROM | SPI_PIC | status); 
*
1856:  MOVF   x96,W
1858:  MOVWF  x9E
185A:  MOVFF  97,9F
185E:  MOVFF  98,A0
1862:  MOVF   x99,W
1864:  IORLW  0C
1866:  MOVWF  xA1
1868:  BSF    x9F.0
186A:  MOVF   20,W
186C:  IORWF  x9E,F
186E:  MOVF   21,W
1870:  IORWF  x9F,F
1872:  MOVF   22,W
1874:  IORWF  xA0,F
1876:  MOVF   23,W
1878:  IORWF  xA1,F
187A:  MOVFF  A1,1A8
187E:  MOVFF  A0,1A7
1882:  MOVFF  9F,1A6
1886:  MOVFF  9E,1A5
188A:  CALL   0B4E
....................    //enable 
....................    output_low(CSu); 
188E:  BCF    F94.1
1890:  BCF    F8B.1
....................    spi_write(6); 
1892:  MOVF   FC9,W
1894:  MOVLW  06
1896:  MOVWF  FC9
1898:  RRCF   FC7,W
189A:  BNC   1898
....................    output_high(CSu); 
189C:  BCF    F94.1
189E:  BSF    F8B.1
....................    //write  
....................    output_low(CSu); 
18A0:  BCF    F94.1
18A2:  BCF    F8B.1
....................    spi_write(2); 
18A4:  MOVF   FC9,W
18A6:  MOVLW  02
18A8:  MOVWF  FC9
18AA:  RRCF   FC7,W
18AC:  BNC   18AA
....................    spi_write(0);//addres 
18AE:  MOVF   FC9,W
18B0:  CLRF   FC9
18B2:  RRCF   FC7,W
18B4:  BNC   18B2
....................    spi_write(pp);//page 
18B6:  MOVF   FC9,W
18B8:  MOVFF  95,FC9
18BC:  RRCF   FC7,W
18BE:  BNC   18BC
....................    spi_write(0); 
18C0:  MOVF   FC9,W
18C2:  CLRF   FC9
18C4:  RRCF   FC7,W
18C6:  BNC   18C4
....................    for(k=0;k<256;k++) 
18C8:  CLRF   x9D
18CA:  CLRF   x9C
18CC:  CLRF   x9B
18CE:  CLRF   x9A
18D0:  MOVF   x9D,F
18D2:  BNZ   18FA
18D4:  MOVF   x9C,F
18D6:  BNZ   18FA
18D8:  MOVF   x9B,W
18DA:  SUBLW  00
18DC:  BNC   18FA
....................       spi_write(k); 
18DE:  MOVF   FC9,W
18E0:  MOVFF  9A,FC9
18E4:  RRCF   FC7,W
18E6:  BNC   18E4
18E8:  MOVLW  01
18EA:  ADDWF  x9A,F
18EC:  BTFSC  FD8.0
18EE:  INCF   x9B,F
18F0:  BTFSC  FD8.2
18F2:  INCF   x9C,F
18F4:  BTFSC  FD8.2
18F6:  INCF   x9D,F
18F8:  BRA    18D0
....................    spi_write(k); 
18FA:  MOVF   FC9,W
18FC:  MOVFF  9A,FC9
1900:  RRCF   FC7,W
1902:  BNC   1900
....................    output_high(CSu); 
1904:  BCF    F94.1
1906:  BSF    F8B.1
....................     
....................    delay_ms(20); 
1908:  MOVLW  14
190A:  MOVLB  1
190C:  MOVWF  xAA
190E:  MOVLB  0
1910:  CALL   06E4
....................  
.................... } 
1914:  RETLW  00
.................... void ReadEE(void) 
.................... { 
....................    unsigned char AA[256]; 
.................... unsigned int32 k; 
....................    //read command 
....................    output_low(CSu); 
....................    spi_write(3); 
....................    spi_write(0);//address 
....................    spi_write(0); 
....................    spi_write(0); 
....................    for(k=0;k<256;k++) 
....................       AA[k] = spi_read(0); 
....................  
....................    output_high(CSu); 
....................     
.................... } 
....................  
.................... ///////////////////// Send Serial Commands  ///////////////////////////////// 
.................... void SendCmd(unsigned int32 cmd) 
.................... { 
....................    unsigned char nible; 
....................    delay_ms(1); 
*
0B4E:  MOVLW  01
0B50:  MOVLB  1
0B52:  MOVWF  xAA
0B54:  MOVLB  0
0B56:  RCALL  06E4
....................    nible = (unsigned char)((cmd>>20)&0xf0); 
0B58:  MOVLB  1
0B5A:  RRCF   xA8,W
0B5C:  MOVWF  xAC
0B5E:  RRCF   xA7,W
0B60:  MOVWF  xAB
0B62:  RRCF   xAC,F
0B64:  RRCF   xAB,F
0B66:  RRCF   xAC,F
0B68:  RRCF   xAB,F
0B6A:  RRCF   xAC,F
0B6C:  RRCF   xAB,F
0B6E:  MOVLW  0F
0B70:  ANDWF  xAC,F
0B72:  MOVF   xAB,W
0B74:  ANDLW  F0
0B76:  MOVWF  xA9
....................    printf("%c",nible); 
0B78:  MOVFF  1A9,1AA
0B7C:  MOVLB  0
0B7E:  RCALL  070C
....................    delay_ms(1); 
0B80:  MOVLW  01
0B82:  MOVLB  1
0B84:  MOVWF  xAA
0B86:  MOVLB  0
0B88:  RCALL  06E4
....................    nible = (unsigned char)((cmd>>20)&0x0f); 
0B8A:  MOVLB  1
0B8C:  RRCF   xA8,W
0B8E:  MOVWF  xAC
0B90:  RRCF   xA7,W
0B92:  MOVWF  xAB
0B94:  RRCF   xAC,F
0B96:  RRCF   xAB,F
0B98:  RRCF   xAC,F
0B9A:  RRCF   xAB,F
0B9C:  RRCF   xAC,F
0B9E:  RRCF   xAB,F
0BA0:  MOVLW  0F
0BA2:  ANDWF  xAC,F
0BA4:  MOVF   xAB,W
0BA6:  ANDLW  0F
0BA8:  MOVWF  xA9
....................    printf("%c",nible); 
0BAA:  MOVFF  1A9,1AA
0BAE:  MOVLB  0
0BB0:  RCALL  070C
....................    delay_ms(1); 
0BB2:  MOVLW  01
0BB4:  MOVLB  1
0BB6:  MOVWF  xAA
0BB8:  MOVLB  0
0BBA:  RCALL  06E4
....................    nible = (unsigned char)((cmd>>16)&0x0f); 
0BBC:  MOVLB  1
0BBE:  MOVF   xA7,W
0BC0:  ANDLW  0F
0BC2:  MOVWF  xA9
....................    printf("%c",nible); 
0BC4:  MOVFF  1A9,1AA
0BC8:  MOVLB  0
0BCA:  RCALL  070C
....................    delay_ms(1); 
0BCC:  MOVLW  01
0BCE:  MOVLB  1
0BD0:  MOVWF  xAA
0BD2:  MOVLB  0
0BD4:  RCALL  06E4
....................    nible = (unsigned char)((cmd>>12)&0x0f); 
0BD6:  MOVLB  1
0BD8:  RRCF   xA8,W
0BDA:  MOVWF  xAD
0BDC:  RRCF   xA7,W
0BDE:  MOVWF  xAC
0BE0:  RRCF   xA6,W
0BE2:  MOVWF  xAB
0BE4:  RRCF   xAD,F
0BE6:  RRCF   xAC,F
0BE8:  RRCF   xAB,F
0BEA:  RRCF   xAD,F
0BEC:  RRCF   xAC,F
0BEE:  RRCF   xAB,F
0BF0:  RRCF   xAD,F
0BF2:  RRCF   xAC,F
0BF4:  RRCF   xAB,F
0BF6:  MOVLW  0F
0BF8:  ANDWF  xAD,F
0BFA:  MOVF   xAB,W
0BFC:  ANDLW  0F
0BFE:  MOVWF  xA9
....................    printf("%c",nible); 
0C00:  MOVFF  1A9,1AA
0C04:  MOVLB  0
0C06:  RCALL  070C
....................    delay_ms(1); 
0C08:  MOVLW  01
0C0A:  MOVLB  1
0C0C:  MOVWF  xAA
0C0E:  MOVLB  0
0C10:  RCALL  06E4
....................    nible = (unsigned char)((cmd>>8)&0x0f); 
0C12:  MOVLB  1
0C14:  MOVF   xA6,W
0C16:  ANDLW  0F
0C18:  MOVWF  xA9
....................    printf("%c",nible); 
0C1A:  MOVFF  1A9,1AA
0C1E:  MOVLB  0
0C20:  RCALL  070C
....................    delay_ms(1); 
0C22:  MOVLW  01
0C24:  MOVLB  1
0C26:  MOVWF  xAA
0C28:  MOVLB  0
0C2A:  RCALL  06E4
....................    nible = (unsigned char)((cmd>>4)&0x0f); 
0C2C:  MOVLB  1
0C2E:  RRCF   xA8,W
0C30:  MOVWF  xAE
0C32:  RRCF   xA7,W
0C34:  MOVWF  xAD
0C36:  RRCF   xA6,W
0C38:  MOVWF  xAC
0C3A:  RRCF   xA5,W
0C3C:  MOVWF  xAB
0C3E:  RRCF   xAE,F
0C40:  RRCF   xAD,F
0C42:  RRCF   xAC,F
0C44:  RRCF   xAB,F
0C46:  RRCF   xAE,F
0C48:  RRCF   xAD,F
0C4A:  RRCF   xAC,F
0C4C:  RRCF   xAB,F
0C4E:  RRCF   xAE,F
0C50:  RRCF   xAD,F
0C52:  RRCF   xAC,F
0C54:  RRCF   xAB,F
0C56:  MOVLW  0F
0C58:  ANDWF  xAE,F
0C5A:  MOVF   xAB,W
0C5C:  ANDLW  0F
0C5E:  MOVWF  xA9
....................    printf("%c",nible); 
0C60:  MOVFF  1A9,1AA
0C64:  MOVLB  0
0C66:  RCALL  070C
....................    delay_ms(1); 
0C68:  MOVLW  01
0C6A:  MOVLB  1
0C6C:  MOVWF  xAA
0C6E:  MOVLB  0
0C70:  RCALL  06E4
....................    nible = (unsigned char)((cmd)&0x0f); 
0C72:  MOVLB  1
0C74:  MOVF   xA5,W
0C76:  ANDLW  0F
0C78:  MOVWF  xA9
....................    printf("%c",nible); 
0C7A:  MOVFF  1A9,1AA
0C7E:  MOVLB  0
0C80:  RCALL  070C
....................    delay_ms(5); 
0C82:  MOVLW  05
0C84:  MOVLB  1
0C86:  MOVWF  xAA
0C88:  MOVLB  0
0C8A:  RCALL  06E4
.................... } 
0C8C:  RETLW  00
....................  
.................... ///////////////////////// Select UART /////////////////////////////////// 
.................... void Sel_UART(boolean dev) 
.................... { 
....................    delay_ms(5); 
*
1916:  MOVLW  05
1918:  MOVLB  1
191A:  MOVWF  xAA
191C:  MOVLB  0
191E:  CALL   06E4
....................    output_bit(UART,dev); 
1922:  MOVLB  1
1924:  MOVF   xA1,F
1926:  BNZ   192C
1928:  BCF    F8B.0
192A:  BRA    192E
192C:  BSF    F8B.0
192E:  BCF    F94.0
....................    delay_ms(5); 
1930:  MOVLW  05
1932:  MOVWF  xAA
1934:  MOVLB  0
1936:  CALL   06E4
.................... } 
193A:  RETLW  00
....................  
.................... //////////////// Start Timer for acknowledge reception     //////////////// 
.................... void Start_TimeOut(void) 
.................... { 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_4);   // setup interrupts 
*
1F52:  MOVLW  A5
1F54:  MOVWF  FCD
....................    set_timer1(0x3CB0); 
1F56:  MOVLW  3C
1F58:  MOVWF  FCF
1F5A:  MOVLW  B0
1F5C:  MOVWF  FCE
....................    enable_interrupts(INT_TIMER1); 
1F5E:  BSF    F9D.0
....................    cntms = 0; 
1F60:  CLRF   1C
....................     
.................... } 
1F62:  RETLW  00
....................  
.................... ///////////////////////// Stop Timer         /////////////////////////////// 
.................... void Stop_TimeOut(void) 
.................... { 
....................    setup_timer_1(T1_DISABLED); 
*
242A:  CLRF   FCD
....................    cntms = 0; 
242C:  CLRF   1C
.................... } 
242E:  RETLW  00
.................... /////////////// LCD Screen     /////////////////////////////////////////// 
.................... void Display(unsigned char mode) 
.................... { 
....................    LcdGotoXY(1,1); 
*
144E:  MOVLW  01
1450:  MOVWF  xBF
1452:  MOVWF  xC0
1454:  RCALL  1098
....................    switch(mode) 
....................    { 
1456:  MOVF   x95,W
1458:  ADDLW  FB
145A:  BTFSC  FD8.0
145C:  BRA    155E
145E:  ADDLW  05
1460:  GOTO   17E6
....................       case REDY: LcdWriteStr("READY                         Test ID=");break; 
1464:  CLRF   FEA
1466:  MOVLW  96
1468:  MOVWF  FE9
146A:  MOVFF  FF2,BF
146E:  BCF    FF2.7
1470:  MOVLW  27
1472:  MOVWF  01
1474:  CLRF   FF7
1476:  MOVLW  00
1478:  CALL   00DE
147C:  TBLRD*-
147E:  TBLRD*+
1480:  MOVFF  FF5,FEE
1484:  DECFSZ 01,F
1486:  BRA    147E
1488:  BTFSC  xBF.7
148A:  BSF    FF2.7
148C:  CLRF   xC2
148E:  MOVLW  96
1490:  MOVWF  xC1
1492:  RCALL  1214
1494:  BRA    155E
....................       case ACQR: LcdWriteStr("ACQUIRING DATA                Test ID=");break; 
1496:  CLRF   FEA
1498:  MOVLW  96
149A:  MOVWF  FE9
149C:  MOVFF  FF2,BF
14A0:  BCF    FF2.7
14A2:  MOVLW  27
14A4:  MOVWF  01
14A6:  CLRF   FF7
14A8:  MOVLW  00
14AA:  CALL   0120
14AE:  TBLRD*-
14B0:  TBLRD*+
14B2:  MOVFF  FF5,FEE
14B6:  DECFSZ 01,F
14B8:  BRA    14B0
14BA:  BTFSC  xBF.7
14BC:  BSF    FF2.7
14BE:  CLRF   xC2
14C0:  MOVLW  96
14C2:  MOVWF  xC1
14C4:  RCALL  1214
14C6:  BRA    155E
....................       case SEND: LcdWriteStr("SENDING TO PC                 Test ID=");break; 
14C8:  CLRF   FEA
14CA:  MOVLW  96
14CC:  MOVWF  FE9
14CE:  MOVFF  FF2,BF
14D2:  BCF    FF2.7
14D4:  MOVLW  27
14D6:  MOVWF  01
14D8:  CLRF   FF7
14DA:  MOVLW  00
14DC:  CALL   0162
14E0:  TBLRD*-
14E2:  TBLRD*+
14E4:  MOVFF  FF5,FEE
14E8:  DECFSZ 01,F
14EA:  BRA    14E2
14EC:  BTFSC  xBF.7
14EE:  BSF    FF2.7
14F0:  CLRF   xC2
14F2:  MOVLW  96
14F4:  MOVWF  xC1
14F6:  RCALL  1214
14F8:  BRA    155E
....................       case ERAS: LcdWriteStr("ERASING MEMORY                Test ID=");break; 
14FA:  CLRF   FEA
14FC:  MOVLW  96
14FE:  MOVWF  FE9
1500:  MOVFF  FF2,BF
1504:  BCF    FF2.7
1506:  MOVLW  27
1508:  MOVWF  01
150A:  CLRF   FF7
150C:  MOVLW  00
150E:  CALL   01A4
1512:  TBLRD*-
1514:  TBLRD*+
1516:  MOVFF  FF5,FEE
151A:  DECFSZ 01,F
151C:  BRA    1514
151E:  BTFSC  xBF.7
1520:  BSF    FF2.7
1522:  CLRF   xC2
1524:  MOVLW  96
1526:  MOVWF  xC1
1528:  RCALL  1214
152A:  BRA    155E
....................       case CNCT: LcdWriteStr("CONECTING TO PC               Test ID=");break; 
152C:  CLRF   FEA
152E:  MOVLW  96
1530:  MOVWF  FE9
1532:  MOVFF  FF2,BF
1536:  BCF    FF2.7
1538:  MOVLW  27
153A:  MOVWF  01
153C:  CLRF   FF7
153E:  MOVLW  00
1540:  CALL   01E6
1544:  TBLRD*-
1546:  TBLRD*+
1548:  MOVFF  FF5,FEE
154C:  DECFSZ 01,F
154E:  BRA    1546
1550:  BTFSC  xBF.7
1552:  BSF    FF2.7
1554:  CLRF   xC2
1556:  MOVLW  96
1558:  MOVWF  xC1
155A:  RCALL  1214
155C:  BRA    155E
....................    } 
....................     
....................    LcdWriteChar((Tid/10)+48);LcdWriteChar((Tid%10)+48); 
155E:  MOVFF  29,CE
1562:  MOVFF  28,CD
1566:  MOVFF  27,CC
156A:  MOVFF  26,CB
156E:  CLRF   xD2
1570:  CLRF   xD1
1572:  CLRF   xD0
1574:  MOVLW  0A
1576:  MOVWF  xCF
1578:  CALL   079E
157C:  MOVFF  03,C2
1580:  MOVFF  02,C1
1584:  MOVFF  01,C0
1588:  MOVFF  00,BF
158C:  MOVLW  30
158E:  ADDWF  xBF,F
1590:  MOVLW  00
1592:  ADDWFC xC0,F
1594:  ADDWFC xC1,F
1596:  ADDWFC xC2,F
1598:  MOVFF  BF,C4
159C:  RCALL  1114
159E:  MOVFF  29,CE
15A2:  MOVFF  28,CD
15A6:  MOVFF  27,CC
15AA:  MOVFF  26,CB
15AE:  CLRF   xD2
15B0:  CLRF   xD1
15B2:  CLRF   xD0
15B4:  MOVLW  0A
15B6:  MOVWF  xCF
15B8:  CALL   079E
15BC:  MOVFF  FEF,BF
15C0:  MOVFF  FEC,C0
15C4:  MOVFF  FEC,C1
15C8:  MOVFF  FEC,C2
15CC:  MOVLW  30
15CE:  ADDWF  xBF,F
15D0:  MOVLW  00
15D2:  ADDWFC xC0,F
15D4:  ADDWFC xC1,F
15D6:  ADDWFC xC2,F
15D8:  MOVFF  BF,C4
15DC:  RCALL  1114
....................    LcdGotoXY(2,1); 
15DE:  MOVLW  02
15E0:  MOVWF  xBF
15E2:  MOVLW  01
15E4:  MOVWF  xC0
15E6:  RCALL  1098
....................    if(online) 
15E8:  BTFSS  4D.1
15EA:  BRA    161E
....................       LcdWriteStr("PC = Online         Test Duration =    s"); 
15EC:  CLRF   FEA
15EE:  MOVLW  96
15F0:  MOVWF  FE9
15F2:  MOVFF  FF2,BF
15F6:  BCF    FF2.7
15F8:  MOVLW  29
15FA:  MOVWF  01
15FC:  CLRF   FF7
15FE:  MOVLW  00
1600:  CALL   0228
1604:  TBLRD*-
1606:  TBLRD*+
1608:  MOVFF  FF5,FEE
160C:  DECFSZ 01,F
160E:  BRA    1606
1610:  BTFSC  xBF.7
1612:  BSF    FF2.7
1614:  CLRF   xC2
1616:  MOVLW  96
1618:  MOVWF  xC1
161A:  RCALL  1214
....................    else 
161C:  BRA    164E
....................       LcdWriteStr("PC = Offline        Test Duration =    s"); 
161E:  CLRF   FEA
1620:  MOVLW  96
1622:  MOVWF  FE9
1624:  MOVFF  FF2,BF
1628:  BCF    FF2.7
162A:  MOVLW  29
162C:  MOVWF  01
162E:  CLRF   FF7
1630:  MOVLW  00
1632:  CALL   026C
1636:  TBLRD*-
1638:  TBLRD*+
163A:  MOVFF  FF5,FEE
163E:  DECFSZ 01,F
1640:  BRA    1638
1642:  BTFSC  xBF.7
1644:  BSF    FF2.7
1646:  CLRF   xC2
1648:  MOVLW  96
164A:  MOVWF  xC1
164C:  RCALL  1214
....................    LcdGotoXY(2,37);sprintf(s,"%03Lu",T);LcdWriteStr(s); 
164E:  MOVLW  02
1650:  MOVWF  xBF
1652:  MOVLW  25
1654:  MOVWF  xC0
1656:  RCALL  1098
1658:  CLRF   x6B
165A:  MOVLW  43
165C:  MOVWF  x6A
165E:  MOVLW  0A
1660:  MOVWF  FE9
1662:  MOVFF  2F,C0
1666:  MOVFF  2E,BF
166A:  RCALL  12EE
166C:  CLRF   xC2
166E:  MOVLW  43
1670:  MOVWF  xC1
1672:  RCALL  1214
....................    LcdGotoXY(3,1); 
1674:  MOVLW  03
1676:  MOVWF  xBF
1678:  MOVLW  01
167A:  MOVWF  xC0
167C:  RCALL  1098
....................    LcdWriteStr("Memory =   %              Battery =    %"); 
167E:  CLRF   FEA
1680:  MOVLW  96
1682:  MOVWF  FE9
1684:  MOVFF  FF2,BF
1688:  BCF    FF2.7
168A:  MOVLW  29
168C:  MOVWF  01
168E:  CLRF   FF7
1690:  MOVLW  00
1692:  CALL   02B0
1696:  TBLRD*-
1698:  TBLRD*+
169A:  MOVFF  FF5,FEE
169E:  DECFSZ 01,F
16A0:  BRA    1698
16A2:  BTFSC  xBF.7
16A4:  BSF    FF2.7
16A6:  CLRF   xC2
16A8:  MOVLW  96
16AA:  MOVWF  xC1
16AC:  RCALL  1214
....................    LcdGotoXY(3,10);sprintf(s,"%2u",M);LcdWriteStr(s); 
16AE:  MOVLW  03
16B0:  MOVWF  xBF
16B2:  MOVLW  0A
16B4:  MOVWF  xC0
16B6:  RCALL  1098
16B8:  CLRF   x6B
16BA:  MOVLW  43
16BC:  MOVWF  x6A
16BE:  MOVFF  34,BF
16C2:  MOVLW  11
16C4:  MOVWF  xC0
16C6:  RCALL  1288
16C8:  CLRF   xC2
16CA:  MOVLW  43
16CC:  MOVWF  xC1
16CE:  RCALL  1214
....................    LcdGotoXY(3,37);sprintf(s,"%3u",B);LcdWriteStr(s); 
16D0:  MOVLW  03
16D2:  MOVWF  xBF
16D4:  MOVLW  25
16D6:  MOVWF  xC0
16D8:  RCALL  1098
16DA:  CLRF   x6B
16DC:  MOVLW  43
16DE:  MOVWF  x6A
16E0:  MOVFF  35,BF
16E4:  MOVLW  13
16E6:  MOVWF  xC0
16E8:  RCALL  1288
16EA:  CLRF   xC2
16EC:  MOVLW  43
16EE:  MOVWF  xC1
16F0:  RCALL  1214
....................    LcdGotoXY(4,1); 
16F2:  MOVLW  04
16F4:  MOVWF  xBF
16F6:  MOVLW  01
16F8:  MOVWF  xC0
16FA:  RCALL  1098
....................    LcdWriteStr("  Ks/s       ohm           Hz           "); 
16FC:  CLRF   FEA
16FE:  MOVLW  96
1700:  MOVWF  FE9
1702:  MOVFF  FF2,BF
1706:  BCF    FF2.7
1708:  MOVLW  29
170A:  MOVWF  01
170C:  CLRF   FF7
170E:  MOVLW  00
1710:  CALL   02F4
1714:  TBLRD*-
1716:  TBLRD*+
1718:  MOVFF  FF5,FEE
171C:  DECFSZ 01,F
171E:  BRA    1716
1720:  BTFSC  xBF.7
1722:  BSF    FF2.7
1724:  CLRF   xC2
1726:  MOVLW  96
1728:  MOVWF  xC1
172A:  RCALL  1214
....................    LcdGotoXY(4,1);sprintf(s,"%02u",R);LcdWriteStr(s); 
172C:  MOVLW  04
172E:  MOVWF  xBF
1730:  MOVLW  01
1732:  MOVWF  xC0
1734:  RCALL  1098
1736:  CLRF   x6B
1738:  MOVLW  43
173A:  MOVWF  x6A
173C:  MOVFF  36,BF
1740:  MOVLW  01
1742:  MOVWF  xC0
1744:  RCALL  1288
1746:  CLRF   xC2
1748:  MOVLW  43
174A:  MOVWF  xC1
174C:  RCALL  1214
....................    LcdGotoXY(4,11);sprintf(s,"%3Lu",Z);LcdWriteStr(s); 
174E:  MOVLW  04
1750:  MOVWF  xBF
1752:  MOVLW  0B
1754:  MOVWF  xC0
1756:  RCALL  1098
1758:  CLRF   x6B
175A:  MOVLW  43
175C:  MOVWF  x6A
175E:  MOVLW  03
1760:  MOVWF  FE9
1762:  MOVFF  3A,C2
1766:  MOVFF  39,C1
176A:  MOVFF  38,C0
176E:  MOVFF  37,BF
1772:  RCALL  13A0
1774:  CLRF   xC2
1776:  MOVLW  43
1778:  MOVWF  xC1
177A:  RCALL  1214
....................    LcdGotoXY(4,24);sprintf(s,"%4Lu",F);LcdWriteStr(s); 
177C:  MOVLW  04
177E:  MOVWF  xBF
1780:  MOVLW  18
1782:  MOVWF  xC0
1784:  RCALL  1098
1786:  CLRF   x6B
1788:  MOVLW  43
178A:  MOVWF  x6A
178C:  MOVLW  04
178E:  MOVWF  FE9
1790:  MOVFF  3E,C2
1794:  MOVFF  3D,C1
1798:  MOVFF  3C,C0
179C:  MOVFF  3B,BF
17A0:  RCALL  13A0
17A2:  CLRF   xC2
17A4:  MOVLW  43
17A6:  MOVWF  xC1
17A8:  RCALL  1214
....................    LcdGotoXY(4,34);sprintf(s,"%4LuKs",N);LcdWriteStr(s); 
17AA:  MOVLW  04
17AC:  MOVWF  xBF
17AE:  MOVLW  22
17B0:  MOVWF  xC0
17B2:  RCALL  1098
17B4:  CLRF   x6B
17B6:  MOVLW  43
17B8:  MOVWF  x6A
17BA:  MOVLW  04
17BC:  MOVWF  FE9
17BE:  MOVFF  42,C2
17C2:  MOVFF  41,C1
17C6:  MOVFF  40,C0
17CA:  MOVFF  3F,BF
17CE:  RCALL  13A0
17D0:  MOVLW  4B
17D2:  MOVWF  xCB
17D4:  RCALL  126C
17D6:  MOVLW  73
17D8:  MOVWF  xCB
17DA:  RCALL  126C
17DC:  CLRF   xC2
17DE:  MOVLW  43
17E0:  MOVWF  xC1
17E2:  RCALL  1214
.................... } 
17E4:  RETLW  00
....................  
.................... void LcdReset() 
.................... { 
....................    int1 EN1,EN2; 
....................    if (Module==1) 
*
0E60:  DECFSZ 24,W
0E62:  BRA    0E6A
....................       {EN1 = 1;EN2 = 0;} 
0E64:  BSF    x95.0
0E66:  BCF    x95.1
....................    else 
0E68:  BRA    0E6E
....................       {EN1 = 0; EN2 = 1;} 
0E6A:  BCF    x95.0
0E6C:  BSF    x95.1
....................     
....................    delay_ms(15); 
0E6E:  MOVLW  0F
0E70:  MOVLB  1
0E72:  MOVWF  xAA
0E74:  MOVLB  0
0E76:  RCALL  06E4
....................    //Send 3 
....................    LCD_D7=0;LCD_D6=0;LCD_D5=1;LCD_D4=1;LCD_E1=EN1;LCD_RS=0;LCD_E2=EN2; 
0E78:  BCF    F84.1
0E7A:  BCF    F84.2
0E7C:  BSF    F80.5
0E7E:  BSF    F84.0
0E80:  BTFSS  x95.0
0E82:  BCF    F83.0
0E84:  BTFSC  x95.0
0E86:  BSF    F83.0
0E88:  BCF    F80.3
0E8A:  BTFSS  x95.1
0E8C:  BCF    F80.2
0E8E:  BTFSC  x95.1
0E90:  BSF    F80.2
....................    LCD_E1=0;LCD_E2=0; 
0E92:  BCF    F83.0
0E94:  BCF    F80.2
....................    delay_ms(5); 
0E96:  MOVLW  05
0E98:  MOVLB  1
0E9A:  MOVWF  xAA
0E9C:  MOVLB  0
0E9E:  RCALL  06E4
....................     
....................    LCD_D7=0;LCD_D6=0;LCD_D5=1;LCD_D4=1;LCD_E1=EN1;LCD_RS=0;LCD_E2=EN2; 
0EA0:  BCF    F84.1
0EA2:  BCF    F84.2
0EA4:  BSF    F80.5
0EA6:  BSF    F84.0
0EA8:  BTFSS  x95.0
0EAA:  BCF    F83.0
0EAC:  BTFSC  x95.0
0EAE:  BSF    F83.0
0EB0:  BCF    F80.3
0EB2:  BTFSS  x95.1
0EB4:  BCF    F80.2
0EB6:  BTFSC  x95.1
0EB8:  BSF    F80.2
....................    LCD_E1=0;LCD_E2=0; 
0EBA:  BCF    F83.0
0EBC:  BCF    F80.2
....................    delay_ms(5); 
0EBE:  MOVLW  05
0EC0:  MOVLB  1
0EC2:  MOVWF  xAA
0EC4:  MOVLB  0
0EC6:  RCALL  06E4
....................  
....................    LCD_D7=0;LCD_D6=0;LCD_D5=1;LCD_D4=1;LCD_E1=EN1;LCD_RS=0;LCD_E2=EN2; 
0EC8:  BCF    F84.1
0ECA:  BCF    F84.2
0ECC:  BSF    F80.5
0ECE:  BSF    F84.0
0ED0:  BTFSS  x95.0
0ED2:  BCF    F83.0
0ED4:  BTFSC  x95.0
0ED6:  BSF    F83.0
0ED8:  BCF    F80.3
0EDA:  BTFSS  x95.1
0EDC:  BCF    F80.2
0EDE:  BTFSC  x95.1
0EE0:  BSF    F80.2
....................    LCD_E1=0;LCD_E2=0; 
0EE2:  BCF    F83.0
0EE4:  BCF    F80.2
....................    delay_ms(5); 
0EE6:  MOVLW  05
0EE8:  MOVLB  1
0EEA:  MOVWF  xAA
0EEC:  MOVLB  0
0EEE:  CALL   06E4
....................     
....................    LCD_D7=0;LCD_D6=0;LCD_D5=1;LCD_D4=0;LCD_E1=EN1;LCD_RS=0;LCD_E2=EN2; 
0EF2:  BCF    F84.1
0EF4:  BCF    F84.2
0EF6:  BSF    F80.5
0EF8:  BCF    F84.0
0EFA:  BTFSS  x95.0
0EFC:  BCF    F83.0
0EFE:  BTFSC  x95.0
0F00:  BSF    F83.0
0F02:  BCF    F80.3
0F04:  BTFSS  x95.1
0F06:  BCF    F80.2
0F08:  BTFSC  x95.1
0F0A:  BSF    F80.2
....................    LCD_E1=0;LCD_E2=0; 
0F0C:  BCF    F83.0
0F0E:  BCF    F80.2
....................    delay_ms(5); 
0F10:  MOVLW  05
0F12:  MOVLB  1
0F14:  MOVWF  xAA
0F16:  MOVLB  0
0F18:  CALL   06E4
....................  
.................... } 
0F1C:  RETLW  00
.................... void LcdInit () 
.................... { 
....................    Module = 1; 
*
101E:  MOVLW  01
1020:  MOVWF  24
....................    LcdReset(); 
1022:  RCALL  0E60
....................    LcdWriteCmd(0x28);   //Function Set 0x38 
1024:  MOVLW  28
1026:  MOVWF  xC2
1028:  RCALL  0F1E
....................    LcdWriteCmd(0x28);   //Function Set 
102A:  MOVLW  28
102C:  MOVWF  xC2
102E:  RCALL  0F1E
....................    LcdWriteCmd(0x28);   //Function Set 
1030:  MOVLW  28
1032:  MOVWF  xC2
1034:  RCALL  0F1E
....................    LcdWriteCmd(0x06);            //Entry Mode Set 0x06 
1036:  MOVLW  06
1038:  MOVWF  xC2
103A:  RCALL  0F1E
....................    LcdWriteCmd(0x0C);            //Display On  Off Control 0x0C 
103C:  MOVLW  0C
103E:  MOVWF  xC2
1040:  RCALL  0F1E
....................    LcdWriteCmd(0x01); 
1042:  MOVLW  01
1044:  MOVWF  xC2
1046:  RCALL  0F1E
....................    Module = 2; 
1048:  MOVLW  02
104A:  MOVWF  24
....................    LcdReset(); 
104C:  RCALL  0E60
....................    LcdWriteCmd(0x28);   //Function Set 0x38 
104E:  MOVLW  28
1050:  MOVWF  xC2
1052:  RCALL  0F1E
....................    LcdWriteCmd(0x28);   //Function Set 
1054:  MOVLW  28
1056:  MOVWF  xC2
1058:  RCALL  0F1E
....................    LcdWriteCmd(0x28);   //Function Set 
105A:  MOVLW  28
105C:  MOVWF  xC2
105E:  RCALL  0F1E
....................    LcdWriteCmd(0x06);            //Entry Mode Set 0x06 
1060:  MOVLW  06
1062:  MOVWF  xC2
1064:  RCALL  0F1E
....................    LcdWriteCmd(0x0C);            //Display On  Off Control 0x0C 
1066:  MOVLW  0C
1068:  MOVWF  xC2
106A:  RCALL  0F1E
....................    LcdWriteCmd(0x01); 
106C:  MOVLW  01
106E:  MOVWF  xC2
1070:  RCALL  0F1E
....................  } 
1072:  GOTO   254A (RETURN)
....................   
.................... void LcdWriteCmd(unsigned char cmd) 
.................... {  
....................    int1 EN1,EN2; 
....................    if (Module==1) 
*
0F1E:  DECFSZ 24,W
0F20:  BRA    0F28
....................       {EN1 = 1;EN2 = 0;} 
0F22:  BSF    xC3.0
0F24:  BCF    xC3.1
....................    else 
0F26:  BRA    0F2C
....................       {EN1 = 0; EN2 = 1;} 
0F28:  BCF    xC3.0
0F2A:  BSF    xC3.1
....................    delay_us(10); 
0F2C:  MOVLW  06
0F2E:  MOVWF  00
0F30:  DECFSZ 00,F
0F32:  BRA    0F30
0F34:  NOP   
....................    //Upper Nibble    
....................    LCD_D7=(cmd>>7)&1;LCD_D6=(cmd>>6)&1;LCD_D5=(cmd>>5)&1;LCD_D4=(cmd>>4)&1;LCD_E1=EN1;LCD_RS=0;LCD_E2=EN2; 
0F36:  CLRF   00
0F38:  BTFSC  xC2.7
0F3A:  BSF    00.0
0F3C:  MOVF   00,W
0F3E:  ANDLW  01
0F40:  MOVWF  01
0F42:  BTFSS  FE8.0
0F44:  BCF    F84.1
0F46:  BTFSC  FE8.0
0F48:  BSF    F84.1
0F4A:  SWAPF  xC2,W
0F4C:  MOVWF  00
0F4E:  RRCF   00,F
0F50:  RRCF   00,F
0F52:  MOVLW  03
0F54:  ANDWF  00,F
0F56:  MOVF   00,W
0F58:  ANDLW  01
0F5A:  MOVWF  01
0F5C:  BTFSS  FE8.0
0F5E:  BCF    F84.2
0F60:  BTFSC  FE8.0
0F62:  BSF    F84.2
0F64:  SWAPF  xC2,W
0F66:  MOVWF  00
0F68:  RRCF   00,F
0F6A:  MOVLW  07
0F6C:  ANDWF  00,F
0F6E:  MOVF   00,W
0F70:  ANDLW  01
0F72:  BTFSS  FE8.0
0F74:  BCF    F80.5
0F76:  BTFSC  FE8.0
0F78:  BSF    F80.5
0F7A:  SWAPF  xC2,W
0F7C:  MOVWF  00
0F7E:  MOVLW  0F
0F80:  ANDWF  00,F
0F82:  MOVF   00,W
0F84:  ANDLW  01
0F86:  BTFSS  FE8.0
0F88:  BCF    F84.0
0F8A:  BTFSC  FE8.0
0F8C:  BSF    F84.0
0F8E:  BTFSS  xC3.0
0F90:  BCF    F83.0
0F92:  BTFSC  xC3.0
0F94:  BSF    F83.0
0F96:  BCF    F80.3
0F98:  BTFSS  xC3.1
0F9A:  BCF    F80.2
0F9C:  BTFSC  xC3.1
0F9E:  BSF    F80.2
....................    LCD_E1=0;LCD_E2=0; 
0FA0:  BCF    F83.0
0FA2:  BCF    F80.2
....................    delay_us(10); 
0FA4:  MOVLW  06
0FA6:  MOVWF  00
0FA8:  DECFSZ 00,F
0FAA:  BRA    0FA8
0FAC:  NOP   
....................    //Lower Nibble 
....................    LCD_D7=(cmd>>3)&1;LCD_D6=(cmd>>2)&1;LCD_D5=(cmd>>1)&1;LCD_D4=cmd&1;LCD_E1=EN1;LCD_RS=0;LCD_E2=EN2; 
0FAE:  RRCF   xC2,W
0FB0:  MOVWF  00
0FB2:  RRCF   00,F
0FB4:  RRCF   00,F
0FB6:  MOVLW  1F
0FB8:  ANDWF  00,F
0FBA:  MOVF   00,W
0FBC:  ANDLW  01
0FBE:  MOVWF  01
0FC0:  BTFSS  FE8.0
0FC2:  BCF    F84.1
0FC4:  BTFSC  FE8.0
0FC6:  BSF    F84.1
0FC8:  RRCF   xC2,W
0FCA:  MOVWF  00
0FCC:  RRCF   00,F
0FCE:  MOVLW  3F
0FD0:  ANDWF  00,F
0FD2:  MOVF   00,W
0FD4:  ANDLW  01
0FD6:  MOVWF  01
0FD8:  BTFSS  FE8.0
0FDA:  BCF    F84.2
0FDC:  BTFSC  FE8.0
0FDE:  BSF    F84.2
0FE0:  BCF    FD8.0
0FE2:  RRCF   xC2,W
0FE4:  ANDLW  01
0FE6:  BTFSS  FE8.0
0FE8:  BCF    F80.5
0FEA:  BTFSC  FE8.0
0FEC:  BSF    F80.5
0FEE:  MOVF   xC2,W
0FF0:  ANDLW  01
0FF2:  BTFSS  FE8.0
0FF4:  BCF    F84.0
0FF6:  BTFSC  FE8.0
0FF8:  BSF    F84.0
0FFA:  BTFSS  xC3.0
0FFC:  BCF    F83.0
0FFE:  BTFSC  xC3.0
1000:  BSF    F83.0
1002:  BCF    F80.3
1004:  BTFSS  xC3.1
1006:  BCF    F80.2
1008:  BTFSC  xC3.1
100A:  BSF    F80.2
....................    LCD_E1=0;LCD_E2=0; 
100C:  BCF    F83.0
100E:  BCF    F80.2
....................    delay_ms(1); 
1010:  MOVLW  01
1012:  MOVLB  1
1014:  MOVWF  xAA
1016:  MOVLB  0
1018:  CALL   06E4
....................  
.................... } 
101C:  RETLW  00
....................  
.................... void LcdWriteChar (unsigned char dat) 
.................... {  
....................    int1 EN1,EN2; 
....................    if (Module==1) 
*
1114:  DECFSZ 24,W
1116:  BRA    111E
....................       {EN1 = 1;EN2 = 0;} 
1118:  BSF    xC5.0
111A:  BCF    xC5.1
....................    else 
111C:  BRA    1122
....................       {EN1 = 0; EN2 = 1;} 
111E:  BCF    xC5.0
1120:  BSF    xC5.1
....................    delay_us(10); 
1122:  MOVLW  06
1124:  MOVWF  00
1126:  DECFSZ 00,F
1128:  BRA    1126
112A:  NOP   
....................    LCD_D7=(dat>>7)&1;LCD_D6=(dat>>6)&1;LCD_D5=(dat>>5)&1;LCD_D4=(dat>>4)&1;LCD_E1=EN1;LCD_RS=1;LCD_E2=EN2; 
112C:  CLRF   00
112E:  BTFSC  xC4.7
1130:  BSF    00.0
1132:  MOVF   00,W
1134:  ANDLW  01
1136:  MOVWF  01
1138:  BTFSS  FE8.0
113A:  BCF    F84.1
113C:  BTFSC  FE8.0
113E:  BSF    F84.1
1140:  SWAPF  xC4,W
1142:  MOVWF  00
1144:  RRCF   00,F
1146:  RRCF   00,F
1148:  MOVLW  03
114A:  ANDWF  00,F
114C:  MOVF   00,W
114E:  ANDLW  01
1150:  MOVWF  01
1152:  BTFSS  FE8.0
1154:  BCF    F84.2
1156:  BTFSC  FE8.0
1158:  BSF    F84.2
115A:  SWAPF  xC4,W
115C:  MOVWF  00
115E:  RRCF   00,F
1160:  MOVLW  07
1162:  ANDWF  00,F
1164:  MOVF   00,W
1166:  ANDLW  01
1168:  BTFSS  FE8.0
116A:  BCF    F80.5
116C:  BTFSC  FE8.0
116E:  BSF    F80.5
1170:  SWAPF  xC4,W
1172:  MOVWF  00
1174:  MOVLW  0F
1176:  ANDWF  00,F
1178:  MOVF   00,W
117A:  ANDLW  01
117C:  BTFSS  FE8.0
117E:  BCF    F84.0
1180:  BTFSC  FE8.0
1182:  BSF    F84.0
1184:  BTFSS  xC5.0
1186:  BCF    F83.0
1188:  BTFSC  xC5.0
118A:  BSF    F83.0
118C:  BSF    F80.3
118E:  BTFSS  xC5.1
1190:  BCF    F80.2
1192:  BTFSC  xC5.1
1194:  BSF    F80.2
....................    LCD_E1=0;LCD_E2=0; 
1196:  BCF    F83.0
1198:  BCF    F80.2
....................    delay_us(10); 
119A:  MOVLW  06
119C:  MOVWF  00
119E:  DECFSZ 00,F
11A0:  BRA    119E
11A2:  NOP   
....................    LCD_D7=(dat>>3)&1;LCD_D6=(dat>>2)&1;LCD_D5=(dat>>1)&1;LCD_D4=dat&1;LCD_E1=EN1;LCD_RS=1;LCD_E2=EN2; 
11A4:  RRCF   xC4,W
11A6:  MOVWF  00
11A8:  RRCF   00,F
11AA:  RRCF   00,F
11AC:  MOVLW  1F
11AE:  ANDWF  00,F
11B0:  MOVF   00,W
11B2:  ANDLW  01
11B4:  MOVWF  01
11B6:  BTFSS  FE8.0
11B8:  BCF    F84.1
11BA:  BTFSC  FE8.0
11BC:  BSF    F84.1
11BE:  RRCF   xC4,W
11C0:  MOVWF  00
11C2:  RRCF   00,F
11C4:  MOVLW  3F
11C6:  ANDWF  00,F
11C8:  MOVF   00,W
11CA:  ANDLW  01
11CC:  MOVWF  01
11CE:  BTFSS  FE8.0
11D0:  BCF    F84.2
11D2:  BTFSC  FE8.0
11D4:  BSF    F84.2
11D6:  BCF    FD8.0
11D8:  RRCF   xC4,W
11DA:  ANDLW  01
11DC:  BTFSS  FE8.0
11DE:  BCF    F80.5
11E0:  BTFSC  FE8.0
11E2:  BSF    F80.5
11E4:  MOVF   xC4,W
11E6:  ANDLW  01
11E8:  BTFSS  FE8.0
11EA:  BCF    F84.0
11EC:  BTFSC  FE8.0
11EE:  BSF    F84.0
11F0:  BTFSS  xC5.0
11F2:  BCF    F83.0
11F4:  BTFSC  xC5.0
11F6:  BSF    F83.0
11F8:  BSF    F80.3
11FA:  BTFSS  xC5.1
11FC:  BCF    F80.2
11FE:  BTFSC  xC5.1
1200:  BSF    F80.2
....................    LCD_E1=0;LCD_E2=0; 
1202:  BCF    F83.0
1204:  BCF    F80.2
....................    delay_ms(1); 
1206:  MOVLW  01
1208:  MOVLB  1
120A:  MOVWF  xAA
120C:  MOVLB  0
120E:  CALL   06E4
.................... } 
1212:  RETLW  00
.................... void LcdWriteStr(unsigned char *var) 
.................... { 
....................    while(*var)       //till string ends send characters one by one 
....................       LcdWriteChar(*var++); 
1214:  MOVFF  C2,03
1218:  MOVFF  C1,FE9
121C:  MOVFF  C2,FEA
1220:  MOVF   FEF,F
1222:  BZ    1242
1224:  MOVFF  C2,03
1228:  MOVF   xC1,W
122A:  INCF   xC1,F
122C:  BTFSC  FD8.2
122E:  INCF   xC2,F
1230:  MOVWF  FE9
1232:  MOVFF  03,FEA
1236:  MOVFF  FEF,C3
123A:  MOVFF  C3,C4
123E:  RCALL  1114
1240:  BRA    1214
.................... } 
1242:  RETLW  00
....................  
.................... void LcdGotoXY(unsigned char row, unsigned char col) 
.................... { 
....................    switch (row) 
....................    { 
*
1098:  MOVF   xBF,W
109A:  XORLW  01
109C:  BZ    10AC
109E:  XORLW  03
10A0:  BZ    10BE
10A2:  XORLW  01
10A4:  BZ    10D0
10A6:  XORLW  07
10A8:  BZ    10E2
10AA:  BRA    10F4
....................       case 1: Module= 1; LcdWriteCmd(0x80 + col - 1); break; 
10AC:  MOVLW  01
10AE:  MOVWF  24
10B0:  MOVLW  80
10B2:  ADDWF  xC0,W
10B4:  ADDLW  FF
10B6:  MOVWF  xC1
10B8:  MOVWF  xC2
10BA:  RCALL  0F1E
10BC:  BRA    1106
....................       case 2: Module= 1; LcdWriteCmd(0xC0 + col - 1); break; 
10BE:  MOVLW  01
10C0:  MOVWF  24
10C2:  MOVLW  C0
10C4:  ADDWF  xC0,W
10C6:  ADDLW  FF
10C8:  MOVWF  xC1
10CA:  MOVWF  xC2
10CC:  RCALL  0F1E
10CE:  BRA    1106
....................       case 3: Module= 2; LcdWriteCmd(0x80 + col - 1); break; 
10D0:  MOVLW  02
10D2:  MOVWF  24
10D4:  MOVLW  80
10D6:  ADDWF  xC0,W
10D8:  ADDLW  FF
10DA:  MOVWF  xC1
10DC:  MOVWF  xC2
10DE:  RCALL  0F1E
10E0:  BRA    1106
....................       case 4: Module= 2; LcdWriteCmd(0xC0 + col - 1); break; 
10E2:  MOVLW  02
10E4:  MOVWF  24
10E6:  MOVLW  C0
10E8:  ADDWF  xC0,W
10EA:  ADDLW  FF
10EC:  MOVWF  xC1
10EE:  MOVWF  xC2
10F0:  RCALL  0F1E
10F2:  BRA    1106
....................       default:Module= 1; LcdWriteCmd(0x80 + col - 1); break; 
10F4:  MOVLW  01
10F6:  MOVWF  24
10F8:  MOVLW  80
10FA:  ADDWF  xC0,W
10FC:  ADDLW  FF
10FE:  MOVWF  xC1
1100:  MOVWF  xC2
1102:  RCALL  0F1E
1104:  BRA    1106
....................    } 
....................   delay_ms(2); 
1106:  MOVLW  02
1108:  MOVLB  1
110A:  MOVWF  xAA
110C:  MOVLB  0
110E:  CALL   06E4
.................... } 
1112:  RETLW  00
.................... void LcdClear(void) 
.................... { 
....................   Module= 1; LcdWriteCmd(0x01); 
*
1076:  MOVLW  01
1078:  MOVWF  24
107A:  MOVWF  xC2
107C:  RCALL  0F1E
....................   Module= 2; LcdWriteCmd(0x01); 
107E:  MOVLW  02
1080:  MOVWF  24
1082:  MOVLW  01
1084:  MOVWF  xC2
1086:  RCALL  0F1E
....................   delay_ms(2); 
1088:  MOVLW  02
108A:  MOVLB  1
108C:  MOVWF  xAA
108E:  MOVLB  0
1090:  CALL   06E4
.................... } 
1094:  GOTO   254E (RETURN)
....................  
.................... ////////////////////// EEPROM  ////////////////////////////////////////// 
....................  
....................  
....................  
....................  
.................... //      MAIN PROGRAM 
.................... void main() 
.................... { 
*
2430:  CLRF   FF8
2432:  BCF    FD0.7
2434:  BSF    07.7
2436:  CLRF   FEA
2438:  CLRF   FE9
243A:  MOVLW  08
243C:  MOVWF  FAF
243E:  MOVLW  A6
2440:  MOVWF  FAC
2442:  MOVLW  90
2444:  MOVWF  FAB
2446:  CLRF   30
2448:  CLRF   31
244A:  CLRF   32
244C:  CLRF   34
244E:  MOVLW  64
2450:  MOVWF  35
2452:  BCF    4D.0
2454:  BCF    4D.1
2456:  BCF    4D.2
2458:  CLRF   x61
245A:  CLRF   x60
245C:  MOVLW  3F
245E:  MOVWF  5F
2460:  MOVLW  F0
2462:  MOVWF  5E
2464:  BSF    FC1.0
2466:  BSF    FC1.1
2468:  BSF    FC1.2
246A:  BCF    FC1.3
246C:  MOVLW  07
246E:  MOVWF  FB4
2470:  CLRF   16
2472:  CLRF   17
2474:  CLRF   x6A
2476:  CLRF   x6B
....................   // Configure Resources 
....................    //setup_adc_ports(AN0|VSS_VDD); 
....................    setup_ccp1 (CCP_OFF); 
2478:  BSF    F94.2
247A:  CLRF   FBD
....................    setup_ccp2 (CCP_OFF); 
247C:  BSF    F95.4
247E:  CLRF   FBA
2480:  CLRF   FB7
2482:  CLRF   FB6
....................    //setup_adc(ADC_CLOCK_DIV_16|ADC_TAD_MUL_8); 
....................    setup_adc(ADC_CLOCK_INTERNAL ); 
2484:  BCF    FC1.6
2486:  BSF    FC2.6
2488:  BSF    FC2.7
248A:  BCF    FC1.7
248C:  BSF    FC2.0
....................    setup_psp(PSP_DISABLED); 
248E:  BCF    F96.4
....................    //setup_wdt(WDT_OFF); 
....................    setup_timer_0(RTCC_INTERNAL); 
2490:  MOVLW  80
2492:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
2494:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
2496:  MOVLW  00
2498:  MOVWF  FCA
249A:  MOVLW  00
249C:  MOVWF  FCB
....................    setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
249E:  CLRF   FB1
....................    //setup_comparator(NC_NC_NC_NC); 
....................    //setup_vref(FALSE); 
....................    //setup_oscillator(OSC_4MHZ|OSC_INTRC|OSC_31250|OSC_PLL_OFF); 
....................    //set_adc_channel( 0 ); 
....................    delay_ms(1000); 
24A0:  MOVLW  04
24A2:  MOVWF  x95
24A4:  MOVLW  FA
24A6:  MOVLB  1
24A8:  MOVWF  xAA
24AA:  MOVLB  0
24AC:  CALL   06E4
24B0:  DECFSZ x95,F
24B2:  BRA    24A4
....................    //setup_adc_ports(NO_ANALOGS); 
....................    // EEPROM SETTING USING HARWARE SPI 
....................    //SPI_MASTER = 0x24 SSPEN = 1 
....................    //SPI_SS_DISABLED = 0x24  SSPM2 = 1 
....................    //SPI_L_TO_H = 0x00 CKP=0 
....................    //SPI_H_TO_L = 0x10 CKP=1 
....................    //SPI_XMIT_L_TO_H = 0x4000 CKE = 1 
....................    setup_spi(SPI_MASTER|SPI_L_TO_H|SPI_CLK_DIV_4|SPI_XMIT_L_TO_H);//Mode = 0 that is CKP=0; CKE=1 
24B4:  BCF    FC6.5
24B6:  BCF    F94.5
24B8:  BSF    F94.4
24BA:  BCF    F94.3
24BC:  MOVLW  20
24BE:  MOVWF  FC6
24C0:  MOVLW  40
24C2:  MOVWF  FC7
....................    /* 
....................    ext_int_edge( H_TO_L );   
....................    ext_int_edge( 1, H_TO_L); 
....................    ext_int_edge( 2, H_TO_L); 
....................    enable_interrupts(INT_AD); 
....................    enable_interrupts(INT_EXT); 
....................    enable_interrupts(INT_EXT1); 
....................    enable_interrupts(INT_EXT2); 
....................    */ 
....................    setup_timer_2 (T2_DIV_BY_16, 0xfa, 1);//step 16us, overflow 4ms 
24C4:  MOVLW  00
24C6:  IORLW  06
24C8:  MOVWF  FCA
24CA:  MOVLW  FA
24CC:  MOVWF  FCB
....................    enable_interrupts(INT_TIMER2); 
24CE:  BSF    F9D.1
....................    enable_interrupts(INT_TIMER1); 
24D0:  BSF    F9D.0
....................    enable_interrupts(INT_RDA); 
24D2:  BSF    F9D.5
....................    enable_interrupts(GLOBAL); 
24D4:  MOVLW  C0
24D6:  IORWF  FF2,F
....................     
....................    ADCON1 = 0x0e; 
24D8:  MOVLW  0E
24DA:  MOVWF  FC1
....................    // Configure I/O Directions 
....................    set_tris_a(0b10000001);// bat=in, clk=in 
24DC:  MOVLW  81
24DE:  MOVWF  F92
....................    set_tris_b(0b00000100);//done = in 
24E0:  MOVLW  04
24E2:  MOVWF  F93
....................    set_tris_c(0b10010000);//sdi=in, rx=in 
24E4:  MOVLW  90
24E6:  MOVWF  F94
....................    set_tris_d(0b00000000); 
24E8:  MOVLW  00
24EA:  MOVWF  F95
....................    set_tris_e(0b00000000);//mclr=in 
24EC:  BCF    F96.0
24EE:  BCF    F96.1
24F0:  BCF    F96.2
....................     
....................     
....................     
....................    output_low(START); 
24F2:  BCF    F93.1
24F4:  BCF    F8A.1
....................    output_low(RESET); 
24F6:  BCF    F93.0
24F8:  BCF    F8A.0
....................    output_high(CSu);//EEPROM CS 
24FA:  BCF    F94.1
24FC:  BSF    F8B.1
....................    output_bit(UART,FPGA); 
24FE:  BCF    F8B.0
2500:  BCF    F94.0
....................    output_low(eSDO);//EEPROM SDO 
2502:  BCF    F94.5
2504:  BCF    F8B.5
....................    output_high(eSCLK);//EEPROM SCLK 
2506:  BCF    F94.3
2508:  BSF    F8B.3
....................     
....................    output_high(RESET); 
250A:  BCF    F93.0
250C:  BSF    F8A.0
....................    delay_ms(1); 
250E:  MOVLW  01
2510:  MOVLB  1
2512:  MOVWF  xAA
2514:  MOVLB  0
2516:  CALL   06E4
....................    output_low(RESET); 
251A:  BCF    F93.0
251C:  BCF    F8A.0
....................    delay_ms(10); 
251E:  MOVLW  0A
2520:  MOVLB  1
2522:  MOVWF  xAA
2524:  MOVLB  0
2526:  CALL   06E4
....................     
....................     
....................     
....................     
....................    output_bit(UART,PC); 
252A:  BSF    F8B.0
252C:  BCF    F94.0
....................    printf("Logger by Sajjad"); 
252E:  MOVLW  2A
2530:  MOVWF  FF6
2532:  MOVLW  06
2534:  MOVWF  FF7
2536:  GOTO   0728
....................    output_bit(UART,FPGA); 
253A:  BCF    F8B.0
253C:  BCF    F94.0
....................     
....................     
....................     
....................     
....................     
....................     
....................    ReloadStatus();// reload variables from local mem 
253E:  GOTO   0818
....................     
....................    GenStatus();// update the status 
2542:  CALL   0C8E
....................    LcdInit(); 
2546:  GOTO   101E
....................    LcdClear(); 
254A:  GOTO   1076
....................    LcdGotoXY(2,1); 
254E:  MOVLW  02
2550:  MOVWF  xBF
2552:  MOVLW  01
2554:  MOVWF  xC0
2556:  CALL   1098
....................    LcdWriteStr("            Data Logger ID:"); 
255A:  CLRF   FEA
255C:  MOVLW  6C
255E:  MOVWF  FE9
2560:  MOVFF  FF2,95
2564:  BCF    FF2.7
2566:  MOVLW  1C
2568:  MOVWF  01
256A:  CLRF   FF7
256C:  MOVLW  00
256E:  CALL   0338
2572:  TBLRD*-
2574:  TBLRD*+
2576:  MOVFF  FF5,FEE
257A:  DECFSZ 01,F
257C:  BRA    2574
257E:  BTFSC  x95.7
2580:  BSF    FF2.7
2582:  CLRF   xC2
2584:  MOVLW  6C
2586:  MOVWF  xC1
2588:  CALL   1214
....................    sprintf(s,"%u",Sid);LcdWriteStr(s); 
258C:  CLRF   x6B
258E:  MOVLW  43
2590:  MOVWF  x6A
2592:  MOVFF  2A,BF
2596:  MOVLW  1B
2598:  MOVWF  xC0
259A:  CALL   1288
259E:  CLRF   xC2
25A0:  MOVLW  43
25A2:  MOVWF  xC1
25A4:  CALL   1214
....................    delay_ms(3000); 
25A8:  MOVLW  0C
25AA:  MOVWF  x95
25AC:  MOVLW  FA
25AE:  MOVLB  1
25B0:  MOVWF  xAA
25B2:  MOVLB  0
25B4:  CALL   06E4
25B8:  DECFSZ x95,F
25BA:  BRA    25AC
....................     
....................    Display(REDY); 
25BC:  CLRF   x95
25BE:  CALL   144E
....................  
....................    state = ready; 
25C2:  MOVLW  01
25C4:  MOVWF  25
....................       
....................    while(true) 
....................    { 
....................       if(kflag) 
25C6:  BTFSS  4D.0
25C8:  GOTO   399A
....................       { 
....................          kflag = 0; 
25CC:  BCF    4D.0
....................           
....................          switch(rxChr+state) 
....................          { 
25CE:  MOVF   25,W
25D0:  ADDWF  1E,W
25D2:  MOVWF  01
25D4:  MOVLW  00
25D6:  ADDWFC 1F,W
25D8:  MOVWF  03
25DA:  MOVFF  01,00
25DE:  MOVLW  05
25E0:  SUBWF  03,W
25E2:  BNZ   25EC
25E4:  MOVLW  01
25E6:  SUBWF  00,W
25E8:  BTFSC  FD8.2
25EA:  BRA    2958
25EC:  MOVLW  05
25EE:  SUBWF  03,W
25F0:  BNZ   25FA
25F2:  MOVLW  0F
25F4:  SUBWF  00,W
25F6:  BTFSC  FD8.2
25F8:  BRA    29C6
25FA:  MOVLW  05
25FC:  SUBWF  03,W
25FE:  BNZ   2608
2600:  MOVLW  0E
2602:  SUBWF  00,W
2604:  BTFSC  FD8.2
2606:  BRA    29FA
2608:  MOVLW  05
260A:  SUBWF  03,W
260C:  BNZ   2616
260E:  MOVLW  08
2610:  SUBWF  00,W
2612:  BTFSC  FD8.2
2614:  BRA    2A2E
2616:  MOVLW  05
2618:  SUBWF  03,W
261A:  BNZ   2624
261C:  MOVLW  09
261E:  SUBWF  00,W
2620:  BTFSC  FD8.2
2622:  BRA    2A80
2624:  MOVLW  05
2626:  SUBWF  03,W
2628:  BNZ   2632
262A:  MOVLW  0A
262C:  SUBWF  00,W
262E:  BTFSC  FD8.2
2630:  BRA    2AD0
2632:  MOVLW  01
2634:  SUBWF  03,W
2636:  BNZ   2640
2638:  MOVLW  01
263A:  SUBWF  00,W
263C:  BTFSC  FD8.2
263E:  BRA    2B2E
2640:  MOVLW  01
2642:  SUBWF  03,W
2644:  BNZ   264E
2646:  MOVLW  0B
2648:  SUBWF  00,W
264A:  BTFSC  FD8.2
264C:  BRA    2BD4
264E:  MOVLW  01
2650:  SUBWF  03,W
2652:  BNZ   265C
2654:  MOVLW  0A
2656:  SUBWF  00,W
2658:  BTFSC  FD8.2
265A:  BRA    2C30
265C:  MOVLW  01
265E:  SUBWF  03,W
2660:  BNZ   266A
2662:  MOVLW  09
2664:  SUBWF  00,W
2666:  BTFSC  FD8.2
2668:  BRA    2C8A
266A:  MOVLW  01
266C:  SUBWF  03,W
266E:  BNZ   2678
2670:  MOVLW  08
2672:  SUBWF  00,W
2674:  BTFSC  FD8.2
2676:  BRA    2D20
2678:  MOVLW  01
267A:  SUBWF  03,W
267C:  BNZ   2686
267E:  MOVLW  0E
2680:  SUBWF  00,W
2682:  BTFSC  FD8.2
2684:  BRA    2D54
2686:  MOVLW  01
2688:  SUBWF  03,W
268A:  BNZ   2694
268C:  MOVLW  0F
268E:  SUBWF  00,W
2690:  BTFSC  FD8.2
2692:  BRA    2D88
2694:  MOVLW  01
2696:  SUBWF  03,W
2698:  BNZ   26A2
269A:  MOVLW  05
269C:  SUBWF  00,W
269E:  BTFSC  FD8.2
26A0:  BRA    2DA8
26A2:  MOVLW  01
26A4:  SUBWF  03,W
26A6:  BNZ   26B0
26A8:  MOVLW  06
26AA:  SUBWF  00,W
26AC:  BTFSC  FD8.2
26AE:  BRA    2DA8
26B0:  MOVLW  01
26B2:  SUBWF  03,W
26B4:  BNZ   26BE
26B6:  MOVLW  02
26B8:  SUBWF  00,W
26BA:  BTFSC  FD8.2
26BC:  BRA    2DA8
26BE:  MOVLW  01
26C0:  SUBWF  03,W
26C2:  BNZ   26CC
26C4:  MOVLW  03
26C6:  SUBWF  00,W
26C8:  BTFSC  FD8.2
26CA:  BRA    2DA8
26CC:  MOVLW  01
26CE:  SUBWF  03,W
26D0:  BNZ   26DA
26D2:  MOVLW  04
26D4:  SUBWF  00,W
26D6:  BTFSC  FD8.2
26D8:  BRA    2DA8
26DA:  MOVLW  04
26DC:  SUBWF  03,W
26DE:  BNZ   26E8
26E0:  MOVLW  01
26E2:  SUBWF  00,W
26E4:  BTFSC  FD8.2
26E6:  BRA    2DB6
26E8:  MOVLW  04
26EA:  SUBWF  03,W
26EC:  BNZ   26F6
26EE:  MOVLW  02
26F0:  SUBWF  00,W
26F2:  BTFSC  FD8.2
26F4:  BRA    2E24
26F6:  MOVLW  04
26F8:  SUBWF  03,W
26FA:  BNZ   2704
26FC:  MOVLW  03
26FE:  SUBWF  00,W
2700:  BTFSC  FD8.2
2702:  BRA    2E54
2704:  MOVLW  04
2706:  SUBWF  03,W
2708:  BNZ   2714
270A:  MOVLW  04
270C:  SUBWF  00,W
270E:  BTFSC  FD8.2
2710:  GOTO   2E84
2714:  MOVLW  04
2716:  SUBWF  03,W
2718:  BNZ   2724
271A:  MOVLW  08
271C:  SUBWF  00,W
271E:  BTFSC  FD8.2
2720:  GOTO   2EB4
2724:  MOVLW  04
2726:  SUBWF  03,W
2728:  BNZ   2734
272A:  MOVLW  0E
272C:  SUBWF  00,W
272E:  BTFSC  FD8.2
2730:  GOTO   2EDC
2734:  MOVLW  04
2736:  SUBWF  03,W
2738:  BNZ   2744
273A:  MOVLW  0F
273C:  SUBWF  00,W
273E:  BTFSC  FD8.2
2740:  GOTO   2F04
2744:  MOVLW  04
2746:  SUBWF  03,W
2748:  BNZ   2754
274A:  MOVLW  09
274C:  SUBWF  00,W
274E:  BTFSC  FD8.2
2750:  GOTO   2F2C
2754:  MOVLW  04
2756:  SUBWF  03,W
2758:  BNZ   2764
275A:  MOVLW  0A
275C:  SUBWF  00,W
275E:  BTFSC  FD8.2
2760:  GOTO   2F78
2764:  MOVLW  04
2766:  SUBWF  03,W
2768:  BNZ   2774
276A:  MOVLW  0B
276C:  SUBWF  00,W
276E:  BTFSC  FD8.2
2770:  GOTO   2FEC
2774:  MOVLW  04
2776:  SUBWF  03,W
2778:  BNZ   2784
277A:  MOVLW  0D
277C:  SUBWF  00,W
277E:  BTFSC  FD8.2
2780:  GOTO   3064
2784:  MOVLW  02
2786:  SUBWF  03,W
2788:  BNZ   2794
278A:  MOVLW  05
278C:  SUBWF  00,W
278E:  BTFSC  FD8.2
2790:  GOTO   3094
2794:  MOVLW  02
2796:  SUBWF  03,W
2798:  BNZ   27A4
279A:  MOVLW  06
279C:  SUBWF  00,W
279E:  BTFSC  FD8.2
27A0:  GOTO   30B0
27A4:  MOVLW  02
27A6:  SUBWF  03,W
27A8:  BNZ   27B4
27AA:  MOVLW  02
27AC:  SUBWF  00,W
27AE:  BTFSC  FD8.2
27B0:  GOTO   30E0
27B4:  MOVLW  02
27B6:  SUBWF  03,W
27B8:  BNZ   27C4
27BA:  MOVLW  03
27BC:  SUBWF  00,W
27BE:  BTFSC  FD8.2
27C0:  GOTO   3110
27C4:  MOVLW  02
27C6:  SUBWF  03,W
27C8:  BNZ   27D4
27CA:  MOVLW  08
27CC:  SUBWF  00,W
27CE:  BTFSC  FD8.2
27D0:  GOTO   3140
27D4:  MOVLW  02
27D6:  SUBWF  03,W
27D8:  BNZ   27E4
27DA:  MOVLW  0E
27DC:  SUBWF  00,W
27DE:  BTFSC  FD8.2
27E0:  GOTO   316A
27E4:  MOVLW  02
27E6:  SUBWF  03,W
27E8:  BNZ   27F4
27EA:  MOVLW  0F
27EC:  SUBWF  00,W
27EE:  BTFSC  FD8.2
27F0:  GOTO   3194
27F4:  MOVLW  02
27F6:  SUBWF  03,W
27F8:  BNZ   2804
27FA:  MOVLW  09
27FC:  SUBWF  00,W
27FE:  BTFSC  FD8.2
2800:  GOTO   31BE
2804:  MOVLW  02
2806:  SUBWF  03,W
2808:  BNZ   2814
280A:  MOVLW  0A
280C:  SUBWF  00,W
280E:  BTFSC  FD8.2
2810:  GOTO   320A
2814:  MOVLW  02
2816:  SUBWF  03,W
2818:  BNZ   2824
281A:  MOVLW  0B
281C:  SUBWF  00,W
281E:  BTFSC  FD8.2
2820:  GOTO   327C
2824:  MOVLW  02
2826:  SUBWF  03,W
2828:  BNZ   2834
282A:  MOVLW  0C
282C:  SUBWF  00,W
282E:  BTFSC  FD8.2
2830:  GOTO   32F2
2834:  MOVLW  03
2836:  SUBWF  03,W
2838:  BNZ   2844
283A:  MOVLW  01
283C:  SUBWF  00,W
283E:  BTFSC  FD8.2
2840:  GOTO   3320
2844:  MOVLW  03
2846:  SUBWF  03,W
2848:  BNZ   2854
284A:  MOVLW  06
284C:  SUBWF  00,W
284E:  BTFSC  FD8.2
2850:  GOTO   341C
2854:  MOVLW  03
2856:  SUBWF  03,W
2858:  BNZ   2864
285A:  MOVLW  02
285C:  SUBWF  00,W
285E:  BTFSC  FD8.2
2860:  GOTO   34AC
2864:  MOVLW  03
2866:  SUBWF  03,W
2868:  BNZ   2874
286A:  MOVLW  03
286C:  SUBWF  00,W
286E:  BTFSC  FD8.2
2870:  GOTO   34F0
2874:  MOVLW  03
2876:  SUBWF  03,W
2878:  BNZ   2884
287A:  MOVLW  04
287C:  SUBWF  00,W
287E:  BTFSC  FD8.2
2880:  GOTO   35E2
2884:  MOVLW  03
2886:  SUBWF  03,W
2888:  BNZ   2894
288A:  MOVLW  0D
288C:  SUBWF  00,W
288E:  BTFSC  FD8.2
2890:  GOTO   36DE
2894:  MOVLW  03
2896:  SUBWF  03,W
2898:  BNZ   28A4
289A:  MOVLW  08
289C:  SUBWF  00,W
289E:  BTFSC  FD8.2
28A0:  GOTO   36F6
28A4:  MOVLW  03
28A6:  SUBWF  03,W
28A8:  BNZ   28B4
28AA:  MOVLW  0E
28AC:  SUBWF  00,W
28AE:  BTFSC  FD8.2
28B0:  GOTO   36F6
28B4:  MOVLW  03
28B6:  SUBWF  03,W
28B8:  BNZ   28C4
28BA:  MOVLW  0F
28BC:  SUBWF  00,W
28BE:  BTFSC  FD8.2
28C0:  GOTO   36F6
28C4:  MOVLW  03
28C6:  SUBWF  03,W
28C8:  BNZ   28D4
28CA:  MOVLW  09
28CC:  SUBWF  00,W
28CE:  BTFSC  FD8.2
28D0:  GOTO   36F6
28D4:  MOVLW  03
28D6:  SUBWF  03,W
28D8:  BNZ   28E4
28DA:  MOVLW  0A
28DC:  SUBWF  00,W
28DE:  BTFSC  FD8.2
28E0:  GOTO   36F6
28E4:  MOVLW  03
28E6:  SUBWF  03,W
28E8:  BNZ   28F4
28EA:  MOVLW  0B
28EC:  SUBWF  00,W
28EE:  BTFSC  FD8.2
28F0:  GOTO   36F6
28F4:  MOVLW  0B
28F6:  SUBWF  03,W
28F8:  BNZ   2904
28FA:  MOVLW  10
28FC:  SUBWF  00,W
28FE:  BTFSC  FD8.2
2900:  GOTO   3748
2904:  MOVLW  0C
2906:  SUBWF  03,W
2908:  BNZ   2914
290A:  MOVLW  11
290C:  SUBWF  00,W
290E:  BTFSC  FD8.2
2910:  GOTO   3764
2914:  MOVLW  0D
2916:  SUBWF  03,W
2918:  BNZ   2924
291A:  MOVLW  12
291C:  SUBWF  00,W
291E:  BTFSC  FD8.2
2920:  GOTO   379E
2924:  MOVLW  0D
2926:  SUBWF  03,W
2928:  BNZ   2934
292A:  MOVLW  14
292C:  SUBWF  00,W
292E:  BTFSC  FD8.2
2930:  GOTO   37CA
2934:  MOVLW  0E
2936:  SUBWF  03,W
2938:  BNZ   2944
293A:  MOVLW  13
293C:  SUBWF  00,W
293E:  BTFSC  FD8.2
2940:  GOTO   384E
2944:  MOVLW  0F
2946:  SUBWF  03,W
2948:  BNZ   2954
294A:  MOVLW  15
294C:  SUBWF  00,W
294E:  BTFSC  FD8.2
2950:  GOTO   392E
2954:  GOTO   399A
....................             //////////////////RIGHT////////////////////////////////////////////// 
....................             case rKey+ready: 
....................                LcdGotoXY(2,37);LcdWriteChar('-'); 
2958:  MOVLW  02
295A:  MOVWF  xBF
295C:  MOVLW  25
295E:  MOVWF  xC0
2960:  CALL   1098
2964:  MOVLW  2D
2966:  MOVWF  xC4
2968:  CALL   1114
....................                T2 = T/100; 
296C:  MOVFF  2F,96
2970:  MOVFF  2E,95
2974:  CLRF   x98
2976:  MOVLW  64
2978:  MOVWF  x97
297A:  CALL   1814
297E:  MOVFF  01,32
....................                T1 = T%100; T1=T1/10; 
2982:  MOVFF  2F,96
2986:  MOVFF  2E,95
298A:  CLRF   x98
298C:  MOVLW  64
298E:  MOVWF  x97
2990:  CALL   1814
2994:  MOVFF  00,31
2998:  MOVFF  31,C1
299C:  MOVLW  0A
299E:  MOVWF  xC2
29A0:  CALL   1244
29A4:  MOVFF  01,31
....................                T0 = T%10; 
29A8:  MOVFF  2F,96
29AC:  MOVFF  2E,95
29B0:  CLRF   x98
29B2:  MOVLW  0A
29B4:  MOVWF  x97
29B6:  CALL   1814
29BA:  MOVFF  00,30
....................                state = hunderth; 
29BE:  MOVLW  0F
29C0:  MOVWF  25
....................                break; 
29C2:  GOTO   399A
....................             case rKey+hunderth: 
....................                LcdGotoXY(2,37);LcdWriteChar(T2+48); 
29C6:  MOVLW  02
29C8:  MOVWF  xBF
29CA:  MOVLW  25
29CC:  MOVWF  xC0
29CE:  CALL   1098
29D2:  MOVLW  30
29D4:  ADDWF  32,W
29D6:  MOVWF  x95
29D8:  MOVWF  xC4
29DA:  CALL   1114
....................                LcdGotoXY(2,38);LcdWriteChar('-'); 
29DE:  MOVLW  02
29E0:  MOVWF  xBF
29E2:  MOVLW  26
29E4:  MOVWF  xC0
29E6:  CALL   1098
29EA:  MOVLW  2D
29EC:  MOVWF  xC4
29EE:  CALL   1114
....................                state = tenth; 
29F2:  MOVLW  0E
29F4:  MOVWF  25
....................                break; 
29F6:  GOTO   399A
....................             case rKey+tenth: 
....................                LcdGotoXY(2,38);LcdWriteChar(T1+48); 
29FA:  MOVLW  02
29FC:  MOVWF  xBF
29FE:  MOVLW  26
2A00:  MOVWF  xC0
2A02:  CALL   1098
2A06:  MOVLW  30
2A08:  ADDWF  31,W
2A0A:  MOVWF  x95
2A0C:  MOVWF  xC4
2A0E:  CALL   1114
....................                LcdGotoXY(2,39);LcdWriteChar('-'); 
2A12:  MOVLW  02
2A14:  MOVWF  xBF
2A16:  MOVLW  27
2A18:  MOVWF  xC0
2A1A:  CALL   1098
2A1E:  MOVLW  2D
2A20:  MOVWF  xC4
2A22:  CALL   1114
....................                state = unitary; 
2A26:  MOVLW  08
2A28:  MOVWF  25
....................                break; 
2A2A:  GOTO   399A
....................             case rKey+unitary: 
....................                LcdGotoXY(2,37);sprintf(s,"%03Lu",T);LcdWriteStr(s); 
2A2E:  MOVLW  02
2A30:  MOVWF  xBF
2A32:  MOVLW  25
2A34:  MOVWF  xC0
2A36:  CALL   1098
2A3A:  CLRF   x6B
2A3C:  MOVLW  43
2A3E:  MOVWF  x6A
2A40:  MOVLW  0A
2A42:  MOVWF  FE9
2A44:  MOVFF  2F,C0
2A48:  MOVFF  2E,BF
2A4C:  CALL   12EE
2A50:  CLRF   xC2
2A52:  MOVLW  43
2A54:  MOVWF  xC1
2A56:  CALL   1214
....................                LcdGotoXY(4,1);LcdWriteStr("--"); 
2A5A:  MOVLW  04
2A5C:  MOVWF  xBF
2A5E:  MOVLW  01
2A60:  MOVWF  xC0
2A62:  CALL   1098
2A66:  MOVLW  2D
2A68:  MOVWF  x6C
2A6A:  MOVWF  x6D
2A6C:  CLRF   x6E
2A6E:  CLRF   xC2
2A70:  MOVLW  6C
2A72:  MOVWF  xC1
2A74:  CALL   1214
....................                state = sampling; 
2A78:  MOVLW  09
2A7A:  MOVWF  25
....................                break; 
2A7C:  GOTO   399A
....................             case rKey+sampling: 
....................                LcdGotoXY(4,1);sprintf(s,"%02u",R);LcdWriteStr(s); 
2A80:  MOVLW  04
2A82:  MOVWF  xBF
2A84:  MOVLW  01
2A86:  MOVWF  xC0
2A88:  CALL   1098
2A8C:  CLRF   x6B
2A8E:  MOVLW  43
2A90:  MOVWF  x6A
2A92:  MOVFF  36,BF
2A96:  MOVLW  01
2A98:  MOVWF  xC0
2A9A:  CALL   1288
2A9E:  CLRF   xC2
2AA0:  MOVLW  43
2AA2:  MOVWF  xC1
2AA4:  CALL   1214
....................                LcdGotoXY(4,11);LcdWriteStr("---"); 
2AA8:  MOVLW  04
2AAA:  MOVWF  xBF
2AAC:  MOVLW  0B
2AAE:  MOVWF  xC0
2AB0:  CALL   1098
2AB4:  MOVLW  2D
2AB6:  MOVWF  x6C
2AB8:  MOVWF  x6D
2ABA:  MOVWF  x6E
2ABC:  CLRF   x6F
2ABE:  CLRF   xC2
2AC0:  MOVLW  6C
2AC2:  MOVWF  xC1
2AC4:  CALL   1214
....................                state = impedance; 
2AC8:  MOVLW  0A
2ACA:  MOVWF  25
....................                break; 
2ACC:  GOTO   399A
....................             case rKey+impedance: 
....................                LcdGotoXY(4,11);sprintf(s,"%3Lu",Z);LcdWriteStr(s); 
2AD0:  MOVLW  04
2AD2:  MOVWF  xBF
2AD4:  MOVLW  0B
2AD6:  MOVWF  xC0
2AD8:  CALL   1098
2ADC:  CLRF   x6B
2ADE:  MOVLW  43
2AE0:  MOVWF  x6A
2AE2:  MOVLW  03
2AE4:  MOVWF  FE9
2AE6:  MOVFF  3A,C2
2AEA:  MOVFF  39,C1
2AEE:  MOVFF  38,C0
2AF2:  MOVFF  37,BF
2AF6:  CALL   13A0
2AFA:  CLRF   xC2
2AFC:  MOVLW  43
2AFE:  MOVWF  xC1
2B00:  CALL   1214
....................                LcdGotoXY(4,24);LcdWriteStr("----"); 
2B04:  MOVLW  04
2B06:  MOVWF  xBF
2B08:  MOVLW  18
2B0A:  MOVWF  xC0
2B0C:  CALL   1098
2B10:  MOVLW  2D
2B12:  MOVWF  x6C
2B14:  MOVWF  x6D
2B16:  MOVWF  x6E
2B18:  MOVWF  x6F
2B1A:  CLRF   x70
2B1C:  CLRF   xC2
2B1E:  MOVLW  6C
2B20:  MOVWF  xC1
2B22:  CALL   1214
....................                state = frequency; 
2B26:  MOVLW  0B
2B28:  MOVWF  25
....................                break; 
2B2A:  GOTO   399A
....................             //////////////////LEFT////////////////////////////////////////////// 
....................            case lKey+ready: 
....................                WriteEE(0,EEP0);WriteEE(0,EEP1); 
2B2E:  CLRF   x95
2B30:  CLRF   x99
2B32:  CLRF   x98
2B34:  CLRF   x97
2B36:  CLRF   x96
2B38:  CALL   1856
2B3C:  CLRF   x95
2B3E:  CLRF   x99
2B40:  CLRF   x98
2B42:  MOVLW  02
2B44:  MOVWF  x97
2B46:  CLRF   x96
2B48:  CALL   1856
....................                WriteEE(1,EEP0);WriteEE(1,EEP1); 
2B4C:  MOVLW  01
2B4E:  MOVWF  x95
2B50:  CLRF   x99
2B52:  CLRF   x98
2B54:  CLRF   x97
2B56:  CLRF   x96
2B58:  CALL   1856
2B5C:  MOVLW  01
2B5E:  MOVWF  x95
2B60:  CLRF   x99
2B62:  CLRF   x98
2B64:  MOVLW  02
2B66:  MOVWF  x97
2B68:  CLRF   x96
2B6A:  CALL   1856
....................                WriteEE(2,EEP0);WriteEE(2,EEP1); 
2B6E:  MOVLW  02
2B70:  MOVWF  x95
2B72:  CLRF   x99
2B74:  CLRF   x98
2B76:  CLRF   x97
2B78:  CLRF   x96
2B7A:  CALL   1856
2B7E:  MOVLW  02
2B80:  MOVWF  x95
2B82:  CLRF   x99
2B84:  CLRF   x98
2B86:  MOVWF  x97
2B88:  CLRF   x96
2B8A:  CALL   1856
....................                WriteEE(3,EEP0);WriteEE(3,EEP1); 
2B8E:  MOVLW  03
2B90:  MOVWF  x95
2B92:  CLRF   x99
2B94:  CLRF   x98
2B96:  CLRF   x97
2B98:  CLRF   x96
2B9A:  CALL   1856
2B9E:  MOVLW  03
2BA0:  MOVWF  x95
2BA2:  CLRF   x99
2BA4:  CLRF   x98
2BA6:  MOVLW  02
2BA8:  MOVWF  x97
2BAA:  CLRF   x96
2BAC:  CALL   1856
....................                RecStartAddr = 0; 
2BB0:  CLRF   59
2BB2:  CLRF   58
2BB4:  CLRF   57
2BB6:  CLRF   56
....................                RecStopAddr = 4; 
2BB8:  CLRF   5D
2BBA:  CLRF   5C
2BBC:  CLRF   5B
2BBE:  MOVLW  04
2BC0:  MOVWF  5A
....................                Sel_UART(FPGA); 
2BC2:  MOVLB  1
2BC4:  CLRF   xA1
2BC6:  MOVLB  0
2BC8:  CALL   1916
....................                state = ready; 
2BCC:  MOVLW  01
2BCE:  MOVWF  25
....................                break; 
2BD0:  GOTO   399A
....................            case lKey+frequency: 
....................                LcdGotoXY(4,24);sprintf(s,"%4Lu",F);LcdWriteStr(s); 
2BD4:  MOVLW  04
2BD6:  MOVWF  xBF
2BD8:  MOVLW  18
2BDA:  MOVWF  xC0
2BDC:  CALL   1098
2BE0:  CLRF   x6B
2BE2:  MOVLW  43
2BE4:  MOVWF  x6A
2BE6:  MOVLW  04
2BE8:  MOVWF  FE9
2BEA:  MOVFF  3E,C2
2BEE:  MOVFF  3D,C1
2BF2:  MOVFF  3C,C0
2BF6:  MOVFF  3B,BF
2BFA:  CALL   13A0
2BFE:  CLRF   xC2
2C00:  MOVLW  43
2C02:  MOVWF  xC1
2C04:  CALL   1214
....................                LcdGotoXY(4,11);LcdWriteStr("---"); 
2C08:  MOVLW  04
2C0A:  MOVWF  xBF
2C0C:  MOVLW  0B
2C0E:  MOVWF  xC0
2C10:  CALL   1098
2C14:  MOVLW  2D
2C16:  MOVWF  x6C
2C18:  MOVWF  x6D
2C1A:  MOVWF  x6E
2C1C:  CLRF   x6F
2C1E:  CLRF   xC2
2C20:  MOVLW  6C
2C22:  MOVWF  xC1
2C24:  CALL   1214
....................                state = impedance; 
2C28:  MOVLW  0A
2C2A:  MOVWF  25
....................                break; 
2C2C:  GOTO   399A
....................             case lKey+impedance: 
....................                LcdGotoXY(4,11);sprintf(s,"%3Lu",Z);LcdWriteStr(s); 
2C30:  MOVLW  04
2C32:  MOVWF  xBF
2C34:  MOVLW  0B
2C36:  MOVWF  xC0
2C38:  CALL   1098
2C3C:  CLRF   x6B
2C3E:  MOVLW  43
2C40:  MOVWF  x6A
2C42:  MOVLW  03
2C44:  MOVWF  FE9
2C46:  MOVFF  3A,C2
2C4A:  MOVFF  39,C1
2C4E:  MOVFF  38,C0
2C52:  MOVFF  37,BF
2C56:  CALL   13A0
2C5A:  CLRF   xC2
2C5C:  MOVLW  43
2C5E:  MOVWF  xC1
2C60:  CALL   1214
....................                LcdGotoXY(4,1);LcdWriteStr("--"); 
2C64:  MOVLW  04
2C66:  MOVWF  xBF
2C68:  MOVLW  01
2C6A:  MOVWF  xC0
2C6C:  CALL   1098
2C70:  MOVLW  2D
2C72:  MOVWF  x6C
2C74:  MOVWF  x6D
2C76:  CLRF   x6E
2C78:  CLRF   xC2
2C7A:  MOVLW  6C
2C7C:  MOVWF  xC1
2C7E:  CALL   1214
....................                state = sampling; 
2C82:  MOVLW  09
2C84:  MOVWF  25
....................                break; 
2C86:  GOTO   399A
....................             case lKey+sampling: 
....................                LcdGotoXY(4,1);sprintf(s,"%02u",R);LcdWriteStr(s); 
2C8A:  MOVLW  04
2C8C:  MOVWF  xBF
2C8E:  MOVLW  01
2C90:  MOVWF  xC0
2C92:  CALL   1098
2C96:  CLRF   x6B
2C98:  MOVLW  43
2C9A:  MOVWF  x6A
2C9C:  MOVFF  36,BF
2CA0:  MOVLW  01
2CA2:  MOVWF  xC0
2CA4:  CALL   1288
2CA8:  CLRF   xC2
2CAA:  MOVLW  43
2CAC:  MOVWF  xC1
2CAE:  CALL   1214
....................                LcdGotoXY(2,39);LcdWriteChar('-'); 
2CB2:  MOVLW  02
2CB4:  MOVWF  xBF
2CB6:  MOVLW  27
2CB8:  MOVWF  xC0
2CBA:  CALL   1098
2CBE:  MOVLW  2D
2CC0:  MOVWF  xC4
2CC2:  CALL   1114
....................                T0 = T%10; 
2CC6:  MOVFF  2F,96
2CCA:  MOVFF  2E,95
2CCE:  CLRF   x98
2CD0:  MOVLW  0A
2CD2:  MOVWF  x97
2CD4:  CALL   1814
2CD8:  MOVFF  00,30
....................                T1 = T%100; T1=T1/10; 
2CDC:  MOVFF  2F,96
2CE0:  MOVFF  2E,95
2CE4:  CLRF   x98
2CE6:  MOVLW  64
2CE8:  MOVWF  x97
2CEA:  CALL   1814
2CEE:  MOVFF  00,31
2CF2:  MOVFF  31,C1
2CF6:  MOVLW  0A
2CF8:  MOVWF  xC2
2CFA:  CALL   1244
2CFE:  MOVFF  01,31
....................                T2 = T/100; 
2D02:  MOVFF  2F,96
2D06:  MOVFF  2E,95
2D0A:  CLRF   x98
2D0C:  MOVLW  64
2D0E:  MOVWF  x97
2D10:  CALL   1814
2D14:  MOVFF  01,32
....................                state = unitary; 
2D18:  MOVLW  08
2D1A:  MOVWF  25
....................                break; 
2D1C:  GOTO   399A
....................             case lKey+unitary: 
....................                LcdGotoXY(2,39);LcdWriteChar(T0+48); 
2D20:  MOVLW  02
2D22:  MOVWF  xBF
2D24:  MOVLW  27
2D26:  MOVWF  xC0
2D28:  CALL   1098
2D2C:  MOVLW  30
2D2E:  ADDWF  30,W
2D30:  MOVWF  x95
2D32:  MOVWF  xC4
2D34:  CALL   1114
....................                LcdGotoXY(2,38);LcdWriteChar('-'); 
2D38:  MOVLW  02
2D3A:  MOVWF  xBF
2D3C:  MOVLW  26
2D3E:  MOVWF  xC0
2D40:  CALL   1098
2D44:  MOVLW  2D
2D46:  MOVWF  xC4
2D48:  CALL   1114
....................                state = tenth; 
2D4C:  MOVLW  0E
2D4E:  MOVWF  25
....................                break; 
2D50:  GOTO   399A
....................             case lKey+tenth: 
....................                LcdGotoXY(2,38);LcdWriteChar(T1+48); 
2D54:  MOVLW  02
2D56:  MOVWF  xBF
2D58:  MOVLW  26
2D5A:  MOVWF  xC0
2D5C:  CALL   1098
2D60:  MOVLW  30
2D62:  ADDWF  31,W
2D64:  MOVWF  x95
2D66:  MOVWF  xC4
2D68:  CALL   1114
....................                LcdGotoXY(2,37);LcdWriteChar('-'); 
2D6C:  MOVLW  02
2D6E:  MOVWF  xBF
2D70:  MOVLW  25
2D72:  MOVWF  xC0
2D74:  CALL   1098
2D78:  MOVLW  2D
2D7A:  MOVWF  xC4
2D7C:  CALL   1114
....................                state = hunderth; 
2D80:  MOVLW  0F
2D82:  MOVWF  25
....................                break; 
2D84:  GOTO   399A
....................             case lKey+hunderth: 
....................                LcdGotoXY(2,37);LcdWriteChar(T2+48); 
2D88:  MOVLW  02
2D8A:  MOVWF  xBF
2D8C:  MOVLW  25
2D8E:  MOVWF  xC0
2D90:  CALL   1098
2D94:  MOVLW  30
2D96:  ADDWF  32,W
2D98:  MOVWF  x95
2D9A:  MOVWF  xC4
2D9C:  CALL   1114
....................                state = ready; 
2DA0:  MOVLW  01
2DA2:  MOVWF  25
....................                break; 
2DA4:  GOTO   399A
....................             //return to main from menues 
....................             case lKey+mn_main: 
....................             case lKey+mn_acquire: 
....................             case lKey+mn_conn: 
....................             case lKey+mn_send: 
....................             case lKey+mn_erase: 
....................                Display(REDY); 
2DA8:  CLRF   x95
2DAA:  CALL   144E
....................                state = ready; 
2DAE:  MOVLW  01
2DB0:  MOVWF  25
....................                break; 
2DB2:  GOTO   399A
....................             //////////////////UP////////////////////////////////////////////// 
....................             case uKey+ready: 
....................             /* 
....................                SendPage(0,EEP0); SendPage(0,EEP1); 
....................                SendPage(1,EEP0); SendPage(1,EEP1); 
....................                SendPage(2,EEP0); SendPage(2,EEP1); 
....................                SendPage(3,EEP0); SendPage(3,EEP1); 
....................                */ 
....................                SendPage(31,EEP0); SendPage(31,EEP1); 
2DB6:  CLRF   x98
2DB8:  CLRF   x97
2DBA:  CLRF   x96
2DBC:  MOVLW  1F
2DBE:  MOVWF  x95
2DC0:  CLRF   x9C
2DC2:  CLRF   x9B
2DC4:  CLRF   x9A
2DC6:  CLRF   x99
2DC8:  CALL   193C
2DCC:  CLRF   x98
2DCE:  CLRF   x97
2DD0:  CLRF   x96
2DD2:  MOVLW  1F
2DD4:  MOVWF  x95
2DD6:  CLRF   x9C
2DD8:  CLRF   x9B
2DDA:  MOVLW  02
2DDC:  MOVWF  x9A
2DDE:  CLRF   x99
2DE0:  CALL   193C
....................                SendPage(32,EEP0); SendPage(32,EEP1); 
2DE4:  CLRF   x98
2DE6:  CLRF   x97
2DE8:  CLRF   x96
2DEA:  MOVLW  20
2DEC:  MOVWF  x95
2DEE:  CLRF   x9C
2DF0:  CLRF   x9B
2DF2:  CLRF   x9A
2DF4:  CLRF   x99
2DF6:  CALL   193C
2DFA:  CLRF   x98
2DFC:  CLRF   x97
2DFE:  CLRF   x96
2E00:  MOVLW  20
2E02:  MOVWF  x95
2E04:  CLRF   x9C
2E06:  CLRF   x9B
2E08:  MOVLW  02
2E0A:  MOVWF  x9A
2E0C:  CLRF   x99
2E0E:  CALL   193C
....................                Sel_UART(FPGA); 
2E12:  MOVLB  1
2E14:  CLRF   xA1
2E16:  MOVLB  0
2E18:  CALL   1916
....................                state = ready; 
2E1C:  MOVLW  01
2E1E:  MOVWF  25
....................                break; 
2E20:  GOTO   399A
....................             case uKey+mn_conn: 
....................                LcdGotoXY(1,11);LcdWriteChar('>'); 
2E24:  MOVLW  01
2E26:  MOVWF  xBF
2E28:  MOVLW  0B
2E2A:  MOVWF  xC0
2E2C:  CALL   1098
2E30:  MOVLW  3E
2E32:  MOVWF  xC4
2E34:  CALL   1114
....................                LcdGotoXY(2,11);LcdWriteChar(' '); 
2E38:  MOVLW  02
2E3A:  MOVWF  xBF
2E3C:  MOVLW  0B
2E3E:  MOVWF  xC0
2E40:  CALL   1098
2E44:  MOVLW  20
2E46:  MOVWF  xC4
2E48:  CALL   1114
....................                state = mn_acquire; 
2E4C:  MOVLW  06
2E4E:  MOVWF  25
....................                break; 
2E50:  GOTO   399A
....................             case uKey+mn_send: 
....................                LcdGotoXY(2,11);LcdWriteChar('>'); 
2E54:  MOVLW  02
2E56:  MOVWF  xBF
2E58:  MOVLW  0B
2E5A:  MOVWF  xC0
2E5C:  CALL   1098
2E60:  MOVLW  3E
2E62:  MOVWF  xC4
2E64:  CALL   1114
....................                LcdGotoXY(3,11);LcdWriteChar(' '); 
2E68:  MOVLW  03
2E6A:  MOVWF  xBF
2E6C:  MOVLW  0B
2E6E:  MOVWF  xC0
2E70:  CALL   1098
2E74:  MOVLW  20
2E76:  MOVWF  xC4
2E78:  CALL   1114
....................                state = mn_conn; 
2E7C:  MOVLW  02
2E7E:  MOVWF  25
....................                break; 
2E80:  GOTO   399A
....................             case uKey+mn_erase: 
....................                LcdGotoXY(3,11);LcdWriteChar('>'); 
2E84:  MOVLW  03
2E86:  MOVWF  xBF
2E88:  MOVLW  0B
2E8A:  MOVWF  xC0
2E8C:  CALL   1098
2E90:  MOVLW  3E
2E92:  MOVWF  xC4
2E94:  CALL   1114
....................                LcdGotoXY(4,11);LcdWriteChar(' '); 
2E98:  MOVLW  04
2E9A:  MOVWF  xBF
2E9C:  MOVLW  0B
2E9E:  MOVWF  xC0
2EA0:  CALL   1098
2EA4:  MOVLW  20
2EA6:  MOVWF  xC4
2EA8:  CALL   1114
....................                state = mn_send; 
2EAC:  MOVLW  03
2EAE:  MOVWF  25
....................                break; 
2EB0:  GOTO   399A
....................             case uKey+unitary: 
....................                T0 = T0 + 1;  
2EB4:  MOVLW  01
2EB6:  ADDWF  30,F
....................                if (T0==10) T0= 0; 
2EB8:  MOVF   30,W
2EBA:  SUBLW  0A
2EBC:  BTFSC  FD8.2
2EBE:  CLRF   30
....................                LcdGotoXY(2,39);LcdWriteChar(T0+48); 
2EC0:  MOVLW  02
2EC2:  MOVWF  xBF
2EC4:  MOVLW  27
2EC6:  MOVWF  xC0
2EC8:  CALL   1098
2ECC:  MOVLW  30
2ECE:  ADDWF  30,W
2ED0:  MOVWF  x95
2ED2:  MOVWF  xC4
2ED4:  CALL   1114
....................                break; 
2ED8:  GOTO   399A
....................             case uKey+tenth: 
....................                T1 = T1 + 1;  
2EDC:  MOVLW  01
2EDE:  ADDWF  31,F
....................                if (T1==10) T1= 0; 
2EE0:  MOVF   31,W
2EE2:  SUBLW  0A
2EE4:  BTFSC  FD8.2
2EE6:  CLRF   31
....................                LcdGotoXY(2,38);LcdWriteChar(T1+48); 
2EE8:  MOVLW  02
2EEA:  MOVWF  xBF
2EEC:  MOVLW  26
2EEE:  MOVWF  xC0
2EF0:  CALL   1098
2EF4:  MOVLW  30
2EF6:  ADDWF  31,W
2EF8:  MOVWF  x95
2EFA:  MOVWF  xC4
2EFC:  CALL   1114
....................                break; 
2F00:  GOTO   399A
....................             case uKey+hunderth: 
....................                T2 = T2 + 1;  
2F04:  MOVLW  01
2F06:  ADDWF  32,F
....................                if (T2==10) T2= 0; 
2F08:  MOVF   32,W
2F0A:  SUBLW  0A
2F0C:  BTFSC  FD8.2
2F0E:  CLRF   32
....................                LcdGotoXY(2,37);LcdWriteChar(T2+48); 
2F10:  MOVLW  02
2F12:  MOVWF  xBF
2F14:  MOVLW  25
2F16:  MOVWF  xC0
2F18:  CALL   1098
2F1C:  MOVLW  30
2F1E:  ADDWF  32,W
2F20:  MOVWF  x95
2F22:  MOVWF  xC4
2F24:  CALL   1114
....................                break; 
2F28:  GOTO   399A
....................             case uKey+sampling: 
....................                if(R==1) R = 8; 
2F2C:  DECFSZ 36,W
2F2E:  BRA    2F36
2F30:  MOVLW  08
2F32:  MOVWF  36
....................                else if (R==8) R = 16; 
2F34:  BRA    2F4C
2F36:  MOVF   36,W
2F38:  SUBLW  08
2F3A:  BNZ   2F42
2F3C:  MOVLW  10
2F3E:  MOVWF  36
....................                else if (R==16) R = 1; 
2F40:  BRA    2F4C
2F42:  MOVF   36,W
2F44:  SUBLW  10
2F46:  BNZ   2F4C
2F48:  MOVLW  01
2F4A:  MOVWF  36
....................                LcdGotoXY(4,1);sprintf(s,"%02u",R);LcdWriteStr(s); 
2F4C:  MOVLW  04
2F4E:  MOVWF  xBF
2F50:  MOVLW  01
2F52:  MOVWF  xC0
2F54:  CALL   1098
2F58:  CLRF   x6B
2F5A:  MOVLW  43
2F5C:  MOVWF  x6A
2F5E:  MOVFF  36,BF
2F62:  MOVLW  01
2F64:  MOVWF  xC0
2F66:  CALL   1288
2F6A:  CLRF   xC2
2F6C:  MOVLW  43
2F6E:  MOVWF  xC1
2F70:  CALL   1214
....................                break; 
2F74:  GOTO   399A
....................             case uKey+impedance: 
....................                if(Z==50) Z = 324; 
2F78:  MOVF   37,W
2F7A:  SUBLW  32
2F7C:  BNZ   2F98
2F7E:  MOVF   38,F
2F80:  BNZ   2F98
2F82:  MOVF   39,F
2F84:  BNZ   2F98
2F86:  MOVF   3A,F
2F88:  BNZ   2F98
2F8A:  CLRF   3A
2F8C:  CLRF   39
2F8E:  MOVLW  01
2F90:  MOVWF  38
2F92:  MOVLW  44
2F94:  MOVWF  37
....................                else if (Z==324) Z = 50; 
2F96:  BRA    2FB4
2F98:  MOVF   37,W
2F9A:  SUBLW  44
2F9C:  BNZ   2FB4
2F9E:  DECFSZ 38,W
2FA0:  BRA    2FB4
2FA2:  MOVF   39,F
2FA4:  BNZ   2FB4
2FA6:  MOVF   3A,F
2FA8:  BNZ   2FB4
2FAA:  CLRF   3A
2FAC:  CLRF   39
2FAE:  CLRF   38
2FB0:  MOVLW  32
2FB2:  MOVWF  37
....................                LcdGotoXY(4,11);sprintf(s,"%3Lu",Z);LcdWriteStr(s); 
2FB4:  MOVLW  04
2FB6:  MOVWF  xBF
2FB8:  MOVLW  0B
2FBA:  MOVWF  xC0
2FBC:  CALL   1098
2FC0:  CLRF   x6B
2FC2:  MOVLW  43
2FC4:  MOVWF  x6A
2FC6:  MOVLW  03
2FC8:  MOVWF  FE9
2FCA:  MOVFF  3A,C2
2FCE:  MOVFF  39,C1
2FD2:  MOVFF  38,C0
2FD6:  MOVFF  37,BF
2FDA:  CALL   13A0
2FDE:  CLRF   xC2
2FE0:  MOVLW  43
2FE2:  MOVWF  xC1
2FE4:  CALL   1214
....................                break; 
2FE8:  GOTO   399A
....................             case uKey+frequency: 
....................                if(F==400) F = 4000; 
2FEC:  MOVF   3B,W
2FEE:  SUBLW  90
2FF0:  BNZ   300C
2FF2:  DECFSZ 3C,W
2FF4:  BRA    300C
2FF6:  MOVF   3D,F
2FF8:  BNZ   300C
2FFA:  MOVF   3E,F
2FFC:  BNZ   300C
2FFE:  CLRF   3E
3000:  CLRF   3D
3002:  MOVLW  0F
3004:  MOVWF  3C
3006:  MOVLW  A0
3008:  MOVWF  3B
....................                else if (F==4000) F = 400; 
300A:  BRA    302C
300C:  MOVF   3B,W
300E:  SUBLW  A0
3010:  BNZ   302C
3012:  MOVF   3C,W
3014:  SUBLW  0F
3016:  BNZ   302C
3018:  MOVF   3D,F
301A:  BNZ   302C
301C:  MOVF   3E,F
301E:  BNZ   302C
3020:  CLRF   3E
3022:  CLRF   3D
3024:  MOVLW  01
3026:  MOVWF  3C
3028:  MOVLW  90
302A:  MOVWF  3B
....................                LcdGotoXY(4,24);sprintf(s,"%4Lu",F);LcdWriteStr(s); 
302C:  MOVLW  04
302E:  MOVWF  xBF
3030:  MOVLW  18
3032:  MOVWF  xC0
3034:  CALL   1098
3038:  CLRF   x6B
303A:  MOVLW  43
303C:  MOVWF  x6A
303E:  MOVLW  04
3040:  MOVWF  FE9
3042:  MOVFF  3E,C2
3046:  MOVFF  3D,C1
304A:  MOVFF  3C,C0
304E:  MOVFF  3B,BF
3052:  CALL   13A0
3056:  CLRF   xC2
3058:  MOVLW  43
305A:  MOVWF  xC1
305C:  CALL   1214
....................                break; 
3060:  GOTO   399A
....................             case uKey+mn_yes: 
....................                LcdGotoXY(3,11);LcdWriteChar(' '); 
3064:  MOVLW  03
3066:  MOVWF  xBF
3068:  MOVLW  0B
306A:  MOVWF  xC0
306C:  CALL   1098
3070:  MOVLW  20
3072:  MOVWF  xC4
3074:  CALL   1114
....................                LcdGotoXY(2,11);LcdWriteChar('>'); 
3078:  MOVLW  02
307A:  MOVWF  xBF
307C:  MOVLW  0B
307E:  MOVWF  xC0
3080:  CALL   1098
3084:  MOVLW  3E
3086:  MOVWF  xC4
3088:  CALL   1114
....................                state = mem_erase; 
308C:  MOVLW  0C
308E:  MOVWF  25
....................                break; 
3090:  GOTO   399A
....................             //////////////////DOWN////////////////////////////////////////////// 
....................             case dKey+mn_main: 
....................                LcdGotoXY(1,11);LcdWriteChar('>'); 
3094:  MOVLW  01
3096:  MOVWF  xBF
3098:  MOVLW  0B
309A:  MOVWF  xC0
309C:  CALL   1098
30A0:  MOVLW  3E
30A2:  MOVWF  xC4
30A4:  CALL   1114
....................                state = mn_acquire; 
30A8:  MOVLW  06
30AA:  MOVWF  25
....................                break; 
30AC:  GOTO   399A
....................             case dKey+mn_acquire: 
....................                LcdGotoXY(1,11);LcdWriteChar(' '); 
30B0:  MOVLW  01
30B2:  MOVWF  xBF
30B4:  MOVLW  0B
30B6:  MOVWF  xC0
30B8:  CALL   1098
30BC:  MOVLW  20
30BE:  MOVWF  xC4
30C0:  CALL   1114
....................                LcdGotoXY(2,11);LcdWriteChar('>'); 
30C4:  MOVLW  02
30C6:  MOVWF  xBF
30C8:  MOVLW  0B
30CA:  MOVWF  xC0
30CC:  CALL   1098
30D0:  MOVLW  3E
30D2:  MOVWF  xC4
30D4:  CALL   1114
....................                state = mn_conn; 
30D8:  MOVLW  02
30DA:  MOVWF  25
....................                break; 
30DC:  GOTO   399A
....................             case dKey+mn_conn: 
....................                LcdGotoXY(2,11);LcdWriteChar(' '); 
30E0:  MOVLW  02
30E2:  MOVWF  xBF
30E4:  MOVLW  0B
30E6:  MOVWF  xC0
30E8:  CALL   1098
30EC:  MOVLW  20
30EE:  MOVWF  xC4
30F0:  CALL   1114
....................                LcdGotoXY(3,11);LcdWriteChar('>'); 
30F4:  MOVLW  03
30F6:  MOVWF  xBF
30F8:  MOVLW  0B
30FA:  MOVWF  xC0
30FC:  CALL   1098
3100:  MOVLW  3E
3102:  MOVWF  xC4
3104:  CALL   1114
....................                state = mn_send; 
3108:  MOVLW  03
310A:  MOVWF  25
....................                break; 
310C:  GOTO   399A
....................             case dKey+mn_send: 
....................                LcdGotoXY(3,11);LcdWriteChar(' '); 
3110:  MOVLW  03
3112:  MOVWF  xBF
3114:  MOVLW  0B
3116:  MOVWF  xC0
3118:  CALL   1098
311C:  MOVLW  20
311E:  MOVWF  xC4
3120:  CALL   1114
....................                LcdGotoXY(4,11);LcdWriteChar('>'); 
3124:  MOVLW  04
3126:  MOVWF  xBF
3128:  MOVLW  0B
312A:  MOVWF  xC0
312C:  CALL   1098
3130:  MOVLW  3E
3132:  MOVWF  xC4
3134:  CALL   1114
....................                state = mn_erase; 
3138:  MOVLW  04
313A:  MOVWF  25
....................                break; 
313C:  GOTO   399A
....................             case dKey+unitary: 
....................                T0 = T0 - 1;  
3140:  MOVLW  01
3142:  SUBWF  30,F
....................                if (T0== (-1)) T0= 9; 
3144:  MOVF   30,W
3146:  SUBLW  FF
3148:  BNZ   314E
314A:  MOVLW  09
314C:  MOVWF  30
....................                LcdGotoXY(2,39);LcdWriteChar(T0+48); 
314E:  MOVLW  02
3150:  MOVWF  xBF
3152:  MOVLW  27
3154:  MOVWF  xC0
3156:  CALL   1098
315A:  MOVLW  30
315C:  ADDWF  30,W
315E:  MOVWF  x95
3160:  MOVWF  xC4
3162:  CALL   1114
....................                break; 
3166:  GOTO   399A
....................             case dKey+tenth: 
....................                T1 = T1 - 1;  
316A:  MOVLW  01
316C:  SUBWF  31,F
....................                if (T1== (-1)) T1= 9; 
316E:  MOVF   31,W
3170:  SUBLW  FF
3172:  BNZ   3178
3174:  MOVLW  09
3176:  MOVWF  31
....................                LcdGotoXY(2,38);LcdWriteChar(T1+48); 
3178:  MOVLW  02
317A:  MOVWF  xBF
317C:  MOVLW  26
317E:  MOVWF  xC0
3180:  CALL   1098
3184:  MOVLW  30
3186:  ADDWF  31,W
3188:  MOVWF  x95
318A:  MOVWF  xC4
318C:  CALL   1114
....................                break; 
3190:  GOTO   399A
....................             case dKey+hunderth: 
....................                T2 = T2 - 1;  
3194:  MOVLW  01
3196:  SUBWF  32,F
....................                if (T2== (-1)) T2= 9; 
3198:  MOVF   32,W
319A:  SUBLW  FF
319C:  BNZ   31A2
319E:  MOVLW  09
31A0:  MOVWF  32
....................                LcdGotoXY(2,37);LcdWriteChar(T2+48); 
31A2:  MOVLW  02
31A4:  MOVWF  xBF
31A6:  MOVLW  25
31A8:  MOVWF  xC0
31AA:  CALL   1098
31AE:  MOVLW  30
31B0:  ADDWF  32,W
31B2:  MOVWF  x95
31B4:  MOVWF  xC4
31B6:  CALL   1114
....................                break; 
31BA:  GOTO   399A
....................             case dKey+sampling: 
....................                if(R==1) R = 8; 
31BE:  DECFSZ 36,W
31C0:  BRA    31C8
31C2:  MOVLW  08
31C4:  MOVWF  36
....................                else if (R==8) R = 16; 
31C6:  BRA    31DE
31C8:  MOVF   36,W
31CA:  SUBLW  08
31CC:  BNZ   31D4
31CE:  MOVLW  10
31D0:  MOVWF  36
....................                else if (R==16) R = 1; 
31D2:  BRA    31DE
31D4:  MOVF   36,W
31D6:  SUBLW  10
31D8:  BNZ   31DE
31DA:  MOVLW  01
31DC:  MOVWF  36
....................                LcdGotoXY(4,1);sprintf(s,"%02u",R);LcdWriteStr(s); 
31DE:  MOVLW  04
31E0:  MOVWF  xBF
31E2:  MOVLW  01
31E4:  MOVWF  xC0
31E6:  CALL   1098
31EA:  CLRF   x6B
31EC:  MOVLW  43
31EE:  MOVWF  x6A
31F0:  MOVFF  36,BF
31F4:  MOVLW  01
31F6:  MOVWF  xC0
31F8:  CALL   1288
31FC:  CLRF   xC2
31FE:  MOVLW  43
3200:  MOVWF  xC1
3202:  CALL   1214
....................                break; 
3206:  GOTO   399A
....................             case dKey+impedance: 
....................                if(Z==50) Z = 324; 
320A:  MOVF   37,W
320C:  SUBLW  32
320E:  BNZ   322A
3210:  MOVF   38,F
3212:  BNZ   322A
3214:  MOVF   39,F
3216:  BNZ   322A
3218:  MOVF   3A,F
321A:  BNZ   322A
321C:  CLRF   3A
321E:  CLRF   39
3220:  MOVLW  01
3222:  MOVWF  38
3224:  MOVLW  44
3226:  MOVWF  37
....................                else if (Z==324) Z = 50; 
3228:  BRA    3246
322A:  MOVF   37,W
322C:  SUBLW  44
322E:  BNZ   3246
3230:  DECFSZ 38,W
3232:  BRA    3246
3234:  MOVF   39,F
3236:  BNZ   3246
3238:  MOVF   3A,F
323A:  BNZ   3246
323C:  CLRF   3A
323E:  CLRF   39
3240:  CLRF   38
3242:  MOVLW  32
3244:  MOVWF  37
....................                LcdGotoXY(4,11);sprintf(s,"%3Lu",Z);LcdWriteStr(s); 
3246:  MOVLW  04
3248:  MOVWF  xBF
324A:  MOVLW  0B
324C:  MOVWF  xC0
324E:  CALL   1098
3252:  CLRF   x6B
3254:  MOVLW  43
3256:  MOVWF  x6A
3258:  MOVLW  03
325A:  MOVWF  FE9
325C:  MOVFF  3A,C2
3260:  MOVFF  39,C1
3264:  MOVFF  38,C0
3268:  MOVFF  37,BF
326C:  CALL   13A0
3270:  CLRF   xC2
3272:  MOVLW  43
3274:  MOVWF  xC1
3276:  CALL   1214
....................                break; 
327A:  BRA    399A
....................             case dKey+frequency: 
....................                if(F==400) F = 4000; 
327C:  MOVF   3B,W
327E:  SUBLW  90
3280:  BNZ   329C
3282:  DECFSZ 3C,W
3284:  BRA    329C
3286:  MOVF   3D,F
3288:  BNZ   329C
328A:  MOVF   3E,F
328C:  BNZ   329C
328E:  CLRF   3E
3290:  CLRF   3D
3292:  MOVLW  0F
3294:  MOVWF  3C
3296:  MOVLW  A0
3298:  MOVWF  3B
....................                else if (F==4000) F = 400; 
329A:  BRA    32BC
329C:  MOVF   3B,W
329E:  SUBLW  A0
32A0:  BNZ   32BC
32A2:  MOVF   3C,W
32A4:  SUBLW  0F
32A6:  BNZ   32BC
32A8:  MOVF   3D,F
32AA:  BNZ   32BC
32AC:  MOVF   3E,F
32AE:  BNZ   32BC
32B0:  CLRF   3E
32B2:  CLRF   3D
32B4:  MOVLW  01
32B6:  MOVWF  3C
32B8:  MOVLW  90
32BA:  MOVWF  3B
....................                LcdGotoXY(4,24);sprintf(s,"%4Lu",F);LcdWriteStr(s); 
32BC:  MOVLW  04
32BE:  MOVWF  xBF
32C0:  MOVLW  18
32C2:  MOVWF  xC0
32C4:  CALL   1098
32C8:  CLRF   x6B
32CA:  MOVLW  43
32CC:  MOVWF  x6A
32CE:  MOVLW  04
32D0:  MOVWF  FE9
32D2:  MOVFF  3E,C2
32D6:  MOVFF  3D,C1
32DA:  MOVFF  3C,C0
32DE:  MOVFF  3B,BF
32E2:  CALL   13A0
32E6:  CLRF   xC2
32E8:  MOVLW  43
32EA:  MOVWF  xC1
32EC:  CALL   1214
....................                break; 
32F0:  BRA    399A
....................             case dKey+mem_erase: 
....................                LcdGotoXY(2,11);LcdWriteChar(' '); 
32F2:  MOVLW  02
32F4:  MOVWF  xBF
32F6:  MOVLW  0B
32F8:  MOVWF  xC0
32FA:  CALL   1098
32FE:  MOVLW  20
3300:  MOVWF  xC4
3302:  CALL   1114
....................                LcdGotoXY(3,11);LcdWriteChar('>'); 
3306:  MOVLW  03
3308:  MOVWF  xBF
330A:  MOVLW  0B
330C:  MOVWF  xC0
330E:  CALL   1098
3312:  MOVLW  3E
3314:  MOVWF  xC4
3316:  CALL   1114
....................                state = mn_yes; 
331A:  MOVLW  0D
331C:  MOVWF  25
....................                break; 
331E:  BRA    399A
....................             //////////////////OK////////////////////////////////////////////// 
....................             case oKey+ready: 
....................                LcdGotoXY(1,1); 
3320:  MOVLW  01
3322:  MOVWF  xBF
3324:  MOVWF  xC0
3326:  CALL   1098
....................                LcdWriteStr("MENU:      1.Acquire Data               "); 
332A:  CLRF   FEA
332C:  MOVLW  6C
332E:  MOVWF  FE9
3330:  MOVFF  FF2,95
3334:  BCF    FF2.7
3336:  MOVLW  29
3338:  MOVWF  01
333A:  CLRF   FF7
333C:  MOVLW  00
333E:  CALL   036E
3342:  TBLRD*-
3344:  TBLRD*+
3346:  MOVFF  FF5,FEE
334A:  DECFSZ 01,F
334C:  BRA    3344
334E:  BTFSC  x95.7
3350:  BSF    FF2.7
3352:  CLRF   xC2
3354:  MOVLW  6C
3356:  MOVWF  xC1
3358:  CALL   1214
....................                LcdGotoXY(2,1); 
335C:  MOVLW  02
335E:  MOVWF  xBF
3360:  MOVLW  01
3362:  MOVWF  xC0
3364:  CALL   1098
....................                LcdWriteStr("           2.Connect to PC              "); 
3368:  CLRF   FEA
336A:  MOVLW  6C
336C:  MOVWF  FE9
336E:  MOVFF  FF2,95
3372:  BCF    FF2.7
3374:  MOVLW  29
3376:  MOVWF  01
3378:  CLRF   FF7
337A:  MOVLW  00
337C:  CALL   03B2
3380:  TBLRD*-
3382:  TBLRD*+
3384:  MOVFF  FF5,FEE
3388:  DECFSZ 01,F
338A:  BRA    3382
338C:  BTFSC  x95.7
338E:  BSF    FF2.7
3390:  CLRF   xC2
3392:  MOVLW  6C
3394:  MOVWF  xC1
3396:  CALL   1214
....................                LcdGotoXY(3,1); 
339A:  MOVLW  03
339C:  MOVWF  xBF
339E:  MOVLW  01
33A0:  MOVWF  xC0
33A2:  CALL   1098
....................                LcdWriteStr("           3.Send Data                  "); 
33A6:  CLRF   FEA
33A8:  MOVLW  6C
33AA:  MOVWF  FE9
33AC:  MOVFF  FF2,95
33B0:  BCF    FF2.7
33B2:  MOVLW  29
33B4:  MOVWF  01
33B6:  CLRF   FF7
33B8:  MOVLW  00
33BA:  CALL   03F6
33BE:  TBLRD*-
33C0:  TBLRD*+
33C2:  MOVFF  FF5,FEE
33C6:  DECFSZ 01,F
33C8:  BRA    33C0
33CA:  BTFSC  x95.7
33CC:  BSF    FF2.7
33CE:  CLRF   xC2
33D0:  MOVLW  6C
33D2:  MOVWF  xC1
33D4:  CALL   1214
....................                LcdGotoXY(4,1); 
33D8:  MOVLW  04
33DA:  MOVWF  xBF
33DC:  MOVLW  01
33DE:  MOVWF  xC0
33E0:  CALL   1098
....................                LcdWriteStr("           4.Erase Memory               "); 
33E4:  CLRF   FEA
33E6:  MOVLW  6C
33E8:  MOVWF  FE9
33EA:  MOVFF  FF2,95
33EE:  BCF    FF2.7
33F0:  MOVLW  29
33F2:  MOVWF  01
33F4:  CLRF   FF7
33F6:  MOVLW  00
33F8:  CALL   043A
33FC:  TBLRD*-
33FE:  TBLRD*+
3400:  MOVFF  FF5,FEE
3404:  DECFSZ 01,F
3406:  BRA    33FE
3408:  BTFSC  x95.7
340A:  BSF    FF2.7
340C:  CLRF   xC2
340E:  MOVLW  6C
3410:  MOVWF  xC1
3412:  CALL   1214
....................                state = mn_main; 
3416:  MOVLW  05
3418:  MOVWF  25
....................                break; 
341A:  BRA    399A
....................             case oKey+mn_acquire: 
....................              
....................                output_high(RESET); 
341C:  BCF    F93.0
341E:  BSF    F8A.0
....................                delay_ms(1); 
3420:  MOVLW  01
3422:  MOVLB  1
3424:  MOVWF  xAA
3426:  MOVLB  0
3428:  CALL   06E4
....................                output_low(RESET); 
342C:  BCF    F93.0
342E:  BCF    F8A.0
....................     
....................                Display(ACQR); 
3430:  MOVLW  01
3432:  MOVWF  x95
3434:  CALL   144E
....................                //read data from ADC and wait for data_done signal 
....................                Acquire(); 
3438:  GOTO   1C66
....................                 
....................                Display(REDY); 
343C:  CLRF   x95
343E:  CALL   144E
....................                 
....................                LcdGotoXY(2,1); 
3442:  MOVLW  02
3444:  MOVWF  xBF
3446:  MOVLW  01
3448:  MOVWF  xC0
344A:  CALL   1098
....................                sprintf(s,"%Lu",StartAddr);LcdWriteStr(s); 
344E:  CLRF   x6B
3450:  MOVLW  43
3452:  MOVWF  x6A
3454:  MOVLW  41
3456:  MOVWF  FE9
3458:  MOVFF  55,C2
345C:  MOVFF  54,C1
3460:  MOVFF  53,C0
3464:  MOVFF  52,BF
3468:  CALL   13A0
346C:  CLRF   xC2
346E:  MOVLW  43
3470:  MOVWF  xC1
3472:  CALL   1214
....................                LcdWriteChar(' '); 
3476:  MOVLW  20
3478:  MOVWF  xC4
347A:  CALL   1114
....................                sprintf(s,"%Lu",StopAddr);LcdWriteStr(s); 
347E:  CLRF   x6B
3480:  MOVLW  43
3482:  MOVWF  x6A
3484:  MOVLW  41
3486:  MOVWF  FE9
3488:  MOVFF  51,C2
348C:  MOVFF  50,C1
3490:  MOVFF  4F,C0
3494:  MOVFF  4E,BF
3498:  CALL   13A0
349C:  CLRF   xC2
349E:  MOVLW  43
34A0:  MOVWF  xC1
34A2:  CALL   1214
....................                 
....................                state = ready; 
34A6:  MOVLW  01
34A8:  MOVWF  25
....................                break; 
34AA:  BRA    399A
....................             case oKey+mn_conn: 
....................                Sel_UART(PC); 
34AC:  MOVLW  01
34AE:  MOVLB  1
34B0:  MOVWF  xA1
34B2:  MOVLB  0
34B4:  CALL   1916
....................                SendCmd(CMD_CONECT|status); 
34B8:  MOVFF  20,95
34BC:  MOVFF  21,96
34C0:  MOVFF  22,97
34C4:  MOVF   23,W
34C6:  IORLW  0B
34C8:  MOVWF  x98
34CA:  MOVFF  FE8,1A8
34CE:  MOVFF  22,1A7
34D2:  MOVFF  21,1A6
34D6:  MOVFF  20,1A5
34DA:  CALL   0B4E
....................                 
....................                Start_TimeOut(); 
34DE:  CALL   1F52
....................                Display(CNCT); 
34E2:  MOVLW  04
34E4:  MOVWF  x95
34E6:  CALL   144E
....................                 
....................                state = wait_cAck; 
34EA:  MOVLW  10
34EC:  MOVWF  25
....................                break; 
34EE:  BRA    399A
....................             case oKey+mn_send: 
....................                if(online) 
34F0:  BTFSS  4D.1
34F2:  BRA    3586
....................                { 
....................                   Display(SEND); 
34F4:  MOVLW  02
34F6:  MOVWF  x95
34F8:  CALL   144E
....................                   record = 0; 
34FC:  CLRF   x69
34FE:  CLRF   x68
3500:  CLRF   x67
3502:  CLRF   x66
....................                   ReadRec(record); 
3504:  MOVFF  69,98
3508:  MOVFF  68,97
350C:  MOVFF  67,96
3510:  MOVFF  66,95
3514:  CALL   1F64
....................                   Start_TimeOut(); 
3518:  CALL   1F52
....................                    
....................                   LcdGotoXY(2,1); 
351C:  MOVLW  02
351E:  MOVWF  xBF
3520:  MOVLW  01
3522:  MOVWF  xC0
3524:  CALL   1098
....................                   sprintf(s,"%Lu",RecStartAddr);LcdWriteStr(s); 
3528:  CLRF   x6B
352A:  MOVLW  43
352C:  MOVWF  x6A
352E:  MOVLW  41
3530:  MOVWF  FE9
3532:  MOVFF  59,C2
3536:  MOVFF  58,C1
353A:  MOVFF  57,C0
353E:  MOVFF  56,BF
3542:  CALL   13A0
3546:  CLRF   xC2
3548:  MOVLW  43
354A:  MOVWF  xC1
354C:  CALL   1214
....................                   LcdWriteChar(' '); 
3550:  MOVLW  20
3552:  MOVWF  xC4
3554:  CALL   1114
....................                   sprintf(s,"%Lu",RecStopAddr);LcdWriteStr(s); 
3558:  CLRF   x6B
355A:  MOVLW  43
355C:  MOVWF  x6A
355E:  MOVLW  41
3560:  MOVWF  FE9
3562:  MOVFF  5D,C2
3566:  MOVFF  5C,C1
356A:  MOVFF  5B,C0
356E:  MOVFF  5A,BF
3572:  CALL   13A0
3576:  CLRF   xC2
3578:  MOVLW  43
357A:  MOVWF  xC1
357C:  CALL   1214
....................                    
....................                   state = wait_sAck; 
3580:  MOVLW  11
3582:  MOVWF  25
....................                } 
....................                else 
3584:  BRA    35E0
....................                { 
....................                   LcdGotoXY(1,1); 
3586:  MOVLW  01
3588:  MOVWF  xBF
358A:  MOVWF  xC0
358C:  CALL   1098
....................                   LcdWriteStr("Unconnected              "); 
3590:  CLRF   FEA
3592:  MOVLW  6C
3594:  MOVWF  FE9
3596:  MOVFF  FF2,95
359A:  BCF    FF2.7
359C:  MOVLW  1A
359E:  MOVWF  01
35A0:  CLRF   FF7
35A2:  MOVLW  00
35A4:  CALL   047E
35A8:  TBLRD*-
35AA:  TBLRD*+
35AC:  MOVFF  FF5,FEE
35B0:  DECFSZ 01,F
35B2:  BRA    35AA
35B4:  BTFSC  x95.7
35B6:  BSF    FF2.7
35B8:  CLRF   xC2
35BA:  MOVLW  6C
35BC:  MOVWF  xC1
35BE:  CALL   1214
....................                   delay_ms(2000); 
35C2:  MOVLW  08
35C4:  MOVWF  x95
35C6:  MOVLW  FA
35C8:  MOVLB  1
35CA:  MOVWF  xAA
35CC:  MOVLB  0
35CE:  CALL   06E4
35D2:  DECFSZ x95,F
35D4:  BRA    35C6
....................                    
....................                   Display(REDY); 
35D6:  CLRF   x95
35D8:  CALL   144E
....................                   state = ready; 
35DC:  MOVLW  01
35DE:  MOVWF  25
....................                } 
....................                break; 
35E0:  BRA    399A
....................             case oKey+mn_erase: 
....................                LcdGotoXY(1,1); 
35E2:  MOVLW  01
35E4:  MOVWF  xBF
35E6:  MOVWF  xC0
35E8:  CALL   1098
....................                LcdWriteStr("MENU:      Erase Memory?                "); 
35EC:  CLRF   FEA
35EE:  MOVLW  6C
35F0:  MOVWF  FE9
35F2:  MOVFF  FF2,95
35F6:  BCF    FF2.7
35F8:  MOVLW  29
35FA:  MOVWF  01
35FC:  CLRF   FF7
35FE:  MOVLW  00
3600:  CALL   04B2
3604:  TBLRD*-
3606:  TBLRD*+
3608:  MOVFF  FF5,FEE
360C:  DECFSZ 01,F
360E:  BRA    3606
3610:  BTFSC  x95.7
3612:  BSF    FF2.7
3614:  CLRF   xC2
3616:  MOVLW  6C
3618:  MOVWF  xC1
361A:  CALL   1214
....................                LcdGotoXY(2,1); 
361E:  MOVLW  02
3620:  MOVWF  xBF
3622:  MOVLW  01
3624:  MOVWF  xC0
3626:  CALL   1098
....................                LcdWriteStr("          >1.No                         "); 
362A:  CLRF   FEA
362C:  MOVLW  6C
362E:  MOVWF  FE9
3630:  MOVFF  FF2,95
3634:  BCF    FF2.7
3636:  MOVLW  29
3638:  MOVWF  01
363A:  CLRF   FF7
363C:  MOVLW  00
363E:  CALL   04F6
3642:  TBLRD*-
3644:  TBLRD*+
3646:  MOVFF  FF5,FEE
364A:  DECFSZ 01,F
364C:  BRA    3644
364E:  BTFSC  x95.7
3650:  BSF    FF2.7
3652:  CLRF   xC2
3654:  MOVLW  6C
3656:  MOVWF  xC1
3658:  CALL   1214
....................                LcdGotoXY(3,1); 
365C:  MOVLW  03
365E:  MOVWF  xBF
3660:  MOVLW  01
3662:  MOVWF  xC0
3664:  CALL   1098
....................                LcdWriteStr("           2.Yes                        "); 
3668:  CLRF   FEA
366A:  MOVLW  6C
366C:  MOVWF  FE9
366E:  MOVFF  FF2,95
3672:  BCF    FF2.7
3674:  MOVLW  29
3676:  MOVWF  01
3678:  CLRF   FF7
367A:  MOVLW  00
367C:  CALL   053A
3680:  TBLRD*-
3682:  TBLRD*+
3684:  MOVFF  FF5,FEE
3688:  DECFSZ 01,F
368A:  BRA    3682
368C:  BTFSC  x95.7
368E:  BSF    FF2.7
3690:  CLRF   xC2
3692:  MOVLW  6C
3694:  MOVWF  xC1
3696:  CALL   1214
....................                LcdGotoXY(4,1); 
369A:  MOVLW  04
369C:  MOVWF  xBF
369E:  MOVLW  01
36A0:  MOVWF  xC0
36A2:  CALL   1098
....................                LcdWriteStr("                                        "); 
36A6:  CLRF   FEA
36A8:  MOVLW  6C
36AA:  MOVWF  FE9
36AC:  MOVFF  FF2,95
36B0:  BCF    FF2.7
36B2:  MOVLW  29
36B4:  MOVWF  01
36B6:  CLRF   FF7
36B8:  MOVLW  00
36BA:  CALL   057E
36BE:  TBLRD*-
36C0:  TBLRD*+
36C2:  MOVFF  FF5,FEE
36C6:  DECFSZ 01,F
36C8:  BRA    36C0
36CA:  BTFSC  x95.7
36CC:  BSF    FF2.7
36CE:  CLRF   xC2
36D0:  MOVLW  6C
36D2:  MOVWF  xC1
36D4:  CALL   1214
....................                state = mem_erase; 
36D8:  MOVLW  0C
36DA:  MOVWF  25
....................                break; 
36DC:  BRA    399A
....................             case oKey+mn_yes:    
....................                Display(ERAS); 
36DE:  MOVLW  03
36E0:  MOVWF  x95
36E2:  CALL   144E
....................                EraseAll(); 
36E6:  GOTO   2262
....................                 
....................                Display(REDY); 
36EA:  CLRF   x95
36EC:  CALL   144E
....................                state = ready; 
36F0:  MOVLW  01
36F2:  MOVWF  25
....................                break; 
36F4:  BRA    399A
....................             case oKey+unitary: 
....................             case oKey+tenth: 
....................             case oKey+hunderth: 
....................             case oKey+sampling: 
....................             case oKey+impedance: 
....................             case oKey+frequency: 
....................             //case oKey+mem_erase: 
....................                T = T2; 
36F6:  CLRF   2F
36F8:  MOVFF  32,2E
....................                T = T*10 + T1; 
36FC:  MOVFF  2F,96
3700:  MOVFF  2E,95
3704:  CLRF   x98
3706:  MOVLW  0A
3708:  MOVWF  x97
370A:  CALL   240C
370E:  MOVF   31,W
3710:  ADDWF  01,W
3712:  MOVWF  2E
3714:  MOVLW  00
3716:  ADDWFC 02,W
3718:  MOVWF  2F
....................                T = T*10 + T0; 
371A:  MOVFF  2F,96
371E:  MOVFF  2E,95
3722:  CLRF   x98
3724:  MOVLW  0A
3726:  MOVWF  x97
3728:  CALL   240C
372C:  MOVF   30,W
372E:  ADDWF  01,W
3730:  MOVWF  2E
3732:  MOVLW  00
3734:  ADDWFC 02,W
3736:  MOVWF  2F
....................                GenStatus(); 
3738:  CALL   0C8E
....................                Display(REDY); 
373C:  CLRF   x95
373E:  CALL   144E
....................                state = ready; 
3742:  MOVLW  01
3744:  MOVWF  25
....................                break; 
3746:  BRA    399A
....................             //////////////////////////////////////////////////////////////// 
....................             case cAck+wait_cAck://PC Connection ACK 
....................                online = 1; 
3748:  BSF    4D.1
....................                Display(REDY); 
374A:  CLRF   x95
374C:  CALL   144E
....................                Stop_TimeOut(); 
3750:  CALL   242A
....................                Sel_UART(FPGA); 
3754:  MOVLB  1
3756:  CLRF   xA1
3758:  MOVLB  0
375A:  CALL   1916
....................                state = ready; 
375E:  MOVLW  01
3760:  MOVWF  25
....................                break; 
3762:  BRA    399A
....................             //////////////////////////////////////////////////////////////// 
....................             case sAck+wait_sAck://Status Ack 
....................                Stop_TimeOut(); 
3764:  CALL   242A
....................                //send pages from RecStartAddr to RecStopAddr 
....................                //send the first page 
....................                page = RecStartAddr; 
3768:  MOVFF  59,65
376C:  MOVFF  58,64
3770:  MOVFF  57,63
3774:  MOVFF  56,62
....................                SendPage(page,EEP0); 
3778:  MOVFF  65,98
377C:  MOVFF  64,97
3780:  MOVFF  63,96
3784:  MOVFF  62,95
3788:  CLRF   x9C
378A:  CLRF   x9B
378C:  CLRF   x9A
378E:  CLRF   x99
3790:  CALL   193C
....................                Start_TimeOut(); 
3794:  CALL   1F52
....................                //Sel_UART(PC); 
....................                state = wait_pAck1; 
3798:  MOVLW  12
379A:  MOVWF  25
....................     
....................                break; 
379C:  BRA    399A
....................             //////////////////////////////////////////////////////////////// 
....................             case pAck+wait_pAck1://Page Ack 
....................                Stop_TimeOut(); 
379E:  CALL   242A
....................                //send the first page from second eeprom 
....................                SendPage(page,EEP1); 
37A2:  MOVFF  65,98
37A6:  MOVFF  64,97
37AA:  MOVFF  63,96
37AE:  MOVFF  62,95
37B2:  CLRF   x9C
37B4:  CLRF   x9B
37B6:  MOVLW  02
37B8:  MOVWF  x9A
37BA:  CLRF   x99
37BC:  CALL   193C
....................                Start_TimeOut(); 
37C0:  CALL   1F52
....................                state = wait_pAck2; 
37C4:  MOVLW  14
37C6:  MOVWF  25
....................                break; 
37C8:  BRA    399A
....................             case pAck+wait_pAck2: 
....................                Stop_TimeOut(); 
37CA:  CALL   242A
....................                //send the next pages 
....................                page++; 
37CE:  MOVLW  01
37D0:  ADDWF  x62,F
37D2:  BTFSC  FD8.0
37D4:  INCF   x63,F
37D6:  BTFSC  FD8.2
37D8:  INCF   x64,F
37DA:  BTFSC  FD8.2
37DC:  INCF   x65,F
....................                if(page<RecStopAddr) 
37DE:  MOVF   x65,W
37E0:  SUBWF  5D,W
37E2:  BNC   381E
37E4:  BNZ   37FC
37E6:  MOVF   x64,W
37E8:  SUBWF  5C,W
37EA:  BNC   381E
37EC:  BNZ   37FC
37EE:  MOVF   x63,W
37F0:  SUBWF  5B,W
37F2:  BNC   381E
37F4:  BNZ   37FC
37F6:  MOVF   5A,W
37F8:  SUBWF  x62,W
37FA:  BC    381E
....................                { 
....................                   SendPage(page,EEP0); 
37FC:  MOVFF  65,98
3800:  MOVFF  64,97
3804:  MOVFF  63,96
3808:  MOVFF  62,95
380C:  CLRF   x9C
380E:  CLRF   x9B
3810:  CLRF   x9A
3812:  CLRF   x99
3814:  CALL   193C
....................                   state = wait_pAck1; 
3818:  MOVLW  12
381A:  MOVWF  25
....................                } 
....................                else 
381C:  BRA    3848
....................                { 
....................                   //Sel_UART(PC); 
....................                   SendCmd(CMD_EOF|status); 
381E:  MOVFF  20,95
3822:  MOVFF  21,96
3826:  MOVFF  22,97
382A:  MOVF   23,W
382C:  IORLW  0E
382E:  MOVWF  x98
3830:  MOVFF  FE8,1A8
3834:  MOVFF  22,1A7
3838:  MOVFF  21,1A6
383C:  MOVFF  20,1A5
3840:  CALL   0B4E
....................                   state = wait_eAck; 
3844:  MOVLW  13
3846:  MOVWF  25
....................                } 
....................                Start_TimeOut(); 
3848:  CALL   1F52
....................                break; 
384C:  BRA    399A
....................             //////////////////////////////////////////////////////////////// 
....................             case eAck+wait_eAck: 
....................                Stop_TimeOut();                
384E:  CALL   242A
....................                record++; 
3852:  MOVLW  01
3854:  ADDWF  x66,F
3856:  BTFSC  FD8.0
3858:  INCF   x67,F
385A:  BTFSC  FD8.2
385C:  INCF   x68,F
385E:  BTFSC  FD8.2
3860:  INCF   x69,F
....................                if(record<Tid) 
3862:  MOVF   x69,W
3864:  SUBWF  29,W
3866:  BNC   38FE
3868:  BNZ   3880
386A:  MOVF   x68,W
386C:  SUBWF  28,W
386E:  BNC   38FE
3870:  BNZ   3880
3872:  MOVF   x67,W
3874:  SUBWF  27,W
3876:  BNC   38FE
3878:  BNZ   3880
387A:  MOVF   26,W
387C:  SUBWF  x66,W
387E:  BC    38FE
....................                { 
....................                   ReadRec(record); 
3880:  MOVFF  69,98
3884:  MOVFF  68,97
3888:  MOVFF  67,96
388C:  MOVFF  66,95
3890:  CALL   1F64
....................                    
....................                                      
....................                   LcdGotoXY(2,1); 
3894:  MOVLW  02
3896:  MOVWF  xBF
3898:  MOVLW  01
389A:  MOVWF  xC0
389C:  CALL   1098
....................                   sprintf(s,"%Lu",RecStartAddr);LcdWriteStr(s); 
38A0:  CLRF   x6B
38A2:  MOVLW  43
38A4:  MOVWF  x6A
38A6:  MOVLW  41
38A8:  MOVWF  FE9
38AA:  MOVFF  59,C2
38AE:  MOVFF  58,C1
38B2:  MOVFF  57,C0
38B6:  MOVFF  56,BF
38BA:  CALL   13A0
38BE:  CLRF   xC2
38C0:  MOVLW  43
38C2:  MOVWF  xC1
38C4:  CALL   1214
....................                   LcdWriteChar(' '); 
38C8:  MOVLW  20
38CA:  MOVWF  xC4
38CC:  CALL   1114
....................                   sprintf(s,"%Lu",RecStopAddr);LcdWriteStr(s); 
38D0:  CLRF   x6B
38D2:  MOVLW  43
38D4:  MOVWF  x6A
38D6:  MOVLW  41
38D8:  MOVWF  FE9
38DA:  MOVFF  5D,C2
38DE:  MOVFF  5C,C1
38E2:  MOVFF  5B,C0
38E6:  MOVFF  5A,BF
38EA:  CALL   13A0
38EE:  CLRF   xC2
38F0:  MOVLW  43
38F2:  MOVWF  xC1
38F4:  CALL   1214
....................                    
....................                   state = wait_sAck; 
38F8:  MOVLW  11
38FA:  MOVWF  25
....................                } 
....................                else// a record completed 
38FC:  BRA    3928
....................                { 
....................                    
....................                   SendCmd(CMD_EOF2|status); 
38FE:  MOVFF  20,95
3902:  MOVFF  21,96
3906:  MOVFF  22,97
390A:  MOVF   23,W
390C:  IORLW  0F
390E:  MOVWF  x98
3910:  MOVFF  FE8,1A8
3914:  MOVFF  22,1A7
3918:  MOVFF  21,1A6
391C:  MOVFF  20,1A5
3920:  CALL   0B4E
....................                   state = wait_eAck2; 
3924:  MOVLW  15
3926:  MOVWF  25
....................                } 
....................                Start_TimeOut(); 
3928:  CALL   1F52
....................                break; 
392C:  BRA    399A
....................             //////////////////////////////////////////////////////////////// 
....................             case eAck2+wait_eAck2: 
....................                Stop_TimeOut();                
392E:  CALL   242A
....................                // all record completed 
....................                Sel_UART(FPGA); 
3932:  MOVLB  1
3934:  CLRF   xA1
3936:  MOVLB  0
3938:  CALL   1916
....................                online = 0; 
393C:  BCF    4D.1
....................                LcdGotoXY(1,1); 
393E:  MOVLW  01
3940:  MOVWF  xBF
3942:  MOVWF  xC0
3944:  CALL   1098
....................                LcdWriteStr("Sent                     "); 
3948:  CLRF   FEA
394A:  MOVLW  6C
394C:  MOVWF  FE9
394E:  MOVFF  FF2,95
3952:  BCF    FF2.7
3954:  MOVLW  1A
3956:  MOVWF  01
3958:  CLRF   FF7
395A:  MOVLW  00
395C:  CALL   05C2
3960:  TBLRD*-
3962:  TBLRD*+
3964:  MOVFF  FF5,FEE
3968:  DECFSZ 01,F
396A:  BRA    3962
396C:  BTFSC  x95.7
396E:  BSF    FF2.7
3970:  CLRF   xC2
3972:  MOVLW  6C
3974:  MOVWF  xC1
3976:  CALL   1214
....................                delay_ms(2000); 
397A:  MOVLW  08
397C:  MOVWF  x95
397E:  MOVLW  FA
3980:  MOVLB  1
3982:  MOVWF  xAA
3984:  MOVLB  0
3986:  CALL   06E4
398A:  DECFSZ x95,F
398C:  BRA    397E
....................                 
....................                Display(REDY); 
398E:  CLRF   x95
3990:  CALL   144E
....................                state = ready; 
3994:  MOVLW  01
3996:  MOVWF  25
....................                break; 
3998:  BRA    399A
....................             //////////////////////////////////////////////////////////////// 
....................          }//sw key 
....................       }//kflag 
....................    if(expired) 
399A:  BTFSS  4D.2
399C:  BRA    3A1A
....................    { 
....................       expired = 0; 
399E:  BCF    4D.2
....................       switch(state) 
....................       { 
39A0:  MOVLW  10
39A2:  SUBWF  25,W
39A4:  ADDLW  FA
39A6:  BC    3A1A
39A8:  ADDLW  06
39AA:  GOTO   3A20
....................          case wait_cAck: 
....................          case wait_sAck: 
....................          case wait_pAck1: 
....................          case wait_pAck2: 
....................          case wait_eAck: 
....................          case wait_eAck2: 
....................             Stop_TimeOut(); 
39AE:  CALL   242A
....................             Sel_UART(FPGA); 
39B2:  MOVLB  1
39B4:  CLRF   xA1
39B6:  MOVLB  0
39B8:  CALL   1916
....................             online = 0; 
39BC:  BCF    4D.1
....................              
....................             LcdGotoXY(1,1); 
39BE:  MOVLW  01
39C0:  MOVWF  xBF
39C2:  MOVWF  xC0
39C4:  CALL   1098
....................             LcdWriteStr("Error!!!                 "); 
39C8:  CLRF   FEA
39CA:  MOVLW  6C
39CC:  MOVWF  FE9
39CE:  MOVFF  FF2,95
39D2:  BCF    FF2.7
39D4:  MOVLW  1A
39D6:  MOVWF  01
39D8:  CLRF   FF7
39DA:  MOVLW  00
39DC:  CALL   05F6
39E0:  TBLRD*-
39E2:  TBLRD*+
39E4:  MOVFF  FF5,FEE
39E8:  DECFSZ 01,F
39EA:  BRA    39E2
39EC:  BTFSC  x95.7
39EE:  BSF    FF2.7
39F0:  CLRF   xC2
39F2:  MOVLW  6C
39F4:  MOVWF  xC1
39F6:  CALL   1214
....................             delay_ms(2000); 
39FA:  MOVLW  08
39FC:  MOVWF  x95
39FE:  MOVLW  FA
3A00:  MOVLB  1
3A02:  MOVWF  xAA
3A04:  MOVLB  0
3A06:  CALL   06E4
3A0A:  DECFSZ x95,F
3A0C:  BRA    39FE
....................              
....................             Display(REDY); 
3A0E:  CLRF   x95
3A10:  CALL   144E
....................              
....................             state = ready; 
3A14:  MOVLW  01
3A16:  MOVWF  25
....................             break; 
3A18:  BRA    3A1A
....................       }//switch state 
....................    }//expired 
....................    }//while 
3A1A:  GOTO   25C6
....................     
.................... } 
....................  
.................... //          INTERUPT SERVICE ROUTINES 
.................... #int_AD 
.................... void  AD_isr(void)  
3A1E:  SLEEP 
.................... { 
....................    /* 
....................    B=read_adc(ADC_READ_ONLY); 
....................    printf("%u ",B); 
....................    //if(B>245) B = 245; 
....................    if(B>204) 
....................    B = ((B - 205)/4)*10; 
....................    else B = 0; 
....................    //printf("%u\n\r",B); 
....................    if(state == ready) 
....................    { 
....................       LcdGotoXY(3,37);sprintf(s,"%3u",B);LcdWriteStr(s); 
....................    } 
....................    */ 
.................... } 
....................  
*
063C:  BCF    F9E.6
063E:  GOTO   009C
.................... #INT_TIMER1 
.................... void wave_timer()  
.................... { 
....................    set_timer1(0x3CB0); 
0642:  MOVLW  3C
0644:  MOVWF  FCF
0646:  MOVLW  B0
0648:  MOVWF  FCE
....................    cntms++;//200ms 
064A:  INCF   1C,F
....................    if(cntms==50) 
064C:  MOVF   1C,W
064E:  SUBLW  32
0650:  BNZ   0666
....................    { 
....................       cntms = 0; 
0652:  CLRF   1C
....................       switch(state) 
....................       { 
0654:  MOVLW  10
0656:  SUBWF  25,W
0658:  ADDLW  FA
065A:  BC    0666
065C:  ADDLW  06
065E:  GOTO   066C
....................          case wait_cAck: 
....................          case wait_sAck: 
....................          case wait_pAck1: 
....................          case wait_pAck2: 
....................          case wait_eAck: 
....................          case wait_eAck2: 
....................             expired = 1; 
0662:  BSF    4D.2
....................             break; 
0664:  BRA    0666
....................       } 
....................        
....................    } 
.................... } 
0666:  BCF    F9E.0
0668:  GOTO   009C
.................... #INT_TIMER2 
.................... void adc_timer()  
.................... { 
....................    cnt40ms++; 
*
0692:  INCF   1D,F
....................    if(cnt40ms==50) 
0694:  MOVF   1D,W
0696:  SUBLW  32
0698:  BNZ   06A6
....................    { 
....................       cnt40ms = 0; 
069A:  CLRF   1D
....................       B=read_adc(); 
069C:  BSF    FC2.2
069E:  BTFSC  FC2.2
06A0:  BRA    069E
06A2:  MOVFF  FC4,35
....................    } 
.................... } 
06A6:  BCF    F9E.1
06A8:  GOTO   009C
.................... #int_EXT 
.................... void  EXT_Nibble_isr(void)  
.................... {   
.................... } 
....................  
06AC:  BCF    FF2.1
06AE:  GOTO   009C
.................... #int_EXT2 
.................... void  EXT2_busy_isr(void)  
.................... { 
.................... } 
....................  
06B2:  BCF    FF0.1
06B4:  GOTO   009C
.................... #int_EXT1 
.................... void  EXT1_isr(void)  
.................... { 
.................... } 
....................  
06B8:  BCF    FF0.0
06BA:  GOTO   009C
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
....................    rxChr = getc(); 
06BE:  BTFSS  F9E.5
06C0:  BRA    06BE
06C2:  MOVF   FAE,W
06C4:  CLRF   1F
06C6:  MOVWF  1E
....................    rxChr= rxChr<<4; 
06C8:  RLCF   1E,F
06CA:  RLCF   1F,F
06CC:  RLCF   1E,F
06CE:  RLCF   1F,F
06D0:  RLCF   1E,F
06D2:  RLCF   1F,F
06D4:  RLCF   1E,F
06D6:  RLCF   1F,F
06D8:  MOVLW  F0
06DA:  ANDWF  1E,F
....................    kflag = 1; 
06DC:  BSF    4D.0
.................... } 
....................  
....................  
06DE:  BCF    F9E.5
06E0:  GOTO   009C

Configuration Fuses:
   Word  1: 2400   EC NOOSCSEN
   Word  2: 0E0E   BROWNOUT WDT128 NOWDT BORV20 PUT
   Word  3: 0000  
   Word  4: 0081   STVREN NODEBUG NOLVP
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTB NOWRTC
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 07 08 00 00 00 00 01 00 01 
